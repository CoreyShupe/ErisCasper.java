<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultShardManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.bot.sharding</a> &gt; <span class="el_source">DefaultShardManager.java</span></div><h1>DefaultShardManager.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.bot.sharding;

import com.neovisionaries.ws.client.WebSocketFactory;
import gnu.trove.map.TIntObjectMap;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.IntFunction;
import javax.security.auth.login.LoginException;
import net.dv8tion.jda.bot.utils.cache.ShardCacheView;
import net.dv8tion.jda.bot.utils.cache.impl.ShardCacheViewImpl;
import net.dv8tion.jda.core.AccountType;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.OnlineStatus;
import net.dv8tion.jda.core.entities.Game;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.hooks.IEventManager;
import net.dv8tion.jda.core.managers.impl.PresenceImpl;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.JDALogger;
import net.dv8tion.jda.core.utils.SessionController;
import net.dv8tion.jda.core.utils.SessionControllerAdapter;
import net.dv8tion.jda.core.utils.tuple.Pair;
import okhttp3.OkHttpClient;
import org.slf4j.Logger;

/**
 * JDA's default {@link net.dv8tion.jda.bot.sharding.ShardManager ShardManager} implementation. To
 * create new instances use the {@link net.dv8tion.jda.bot.sharding.DefaultShardManagerBuilder
 * DefaultShardManagerBuilder}.
 *
 * @since 3.4
 * @author Aljoscha Grebe
 */
public class DefaultShardManager implements ShardManager {
<span class="nc" id="L52">  public static final Logger LOG = JDALogger.getLog(ShardManager.class);</span>
<span class="nc" id="L53">  public static final ThreadFactory DEFAULT_THREAD_FACTORY =</span>
      r -&gt; {
<span class="nc" id="L55">        final Thread t = new Thread(r, &quot;DefaultShardManager&quot;);</span>
<span class="nc" id="L56">        t.setPriority(Thread.NORM_PRIORITY + 1);</span>
<span class="nc" id="L57">        return t;</span>
      };
  /**
   * The {@link net.dv8tion.jda.core.utils.SessionController SessionController} for this manager.
   */
  protected final SessionController controller;

  /**
   * Whether or not JDA should try to reconnect if a connection-error is encountered. &lt;br&gt;
   * This will use an incremental reconnect (timeouts are increased each time an attempt fails).
   */
  protected final boolean autoReconnect;

  /**
   * The core pool size for the global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} which is used in various locations throughout JDA.
   */
  protected final int corePoolSize;

  /**
   * If enabled, JDA will separate the bulk delete event into individual delete events, but this
   * isn't as efficient as handling a single event would be.
   */
  protected final boolean enableBulkDeleteSplitting;

  /** Whether or not Voice functionality is enabled. */
  protected final boolean enableVoice;

  /**
   * The {@link net.dv8tion.jda.core.hooks.IEventManager IEventManager} used by the ShardManager.
   */
  protected final IEventManager eventManager;

  /** The event listeners for new JDA instances. */
  protected final List&lt;Object&gt; listeners;

  /**
   * The maximum amount of time that JDA will back off to wait when attempting to reconnect the
   * MainWebsocket.
   */
  protected final int maxReconnectDelay;

  /** The executor that is used by the ShardManager internally to create new JDA instances. */
  protected final ScheduledExecutorService executor;

  /** The queue of shards waiting for creation. */
<span class="nc" id="L103">  protected final Queue&lt;Integer&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();</span>

  /**
   * The {@link net.dv8tion.jda.bot.utils.cache.ShardCacheView ShardCacheView} that holds all
   * shards.
   */
  protected ShardCacheViewImpl shards;

  /**
   * The total number of shards.
   *
   * &lt;p&gt;&lt;b&gt;DO NOT CHANGE THIS WHILE SOME SHARD ARE STILL RUNNING !&lt;/b&gt;
   */
  protected int shardsTotal;

  /**
   * The {@link okhttp3.OkHttpClient.Builder OkHttpClient.Builder} that will be used by JDA's
   * requester.
   */
  protected final OkHttpClient.Builder httpClientBuilder;

  /**
   * The {@link com.neovisionaries.ws.client.WebSocketFactory WebSocketFactory} that will be used by
   * JDA's websocket client.
   */
  protected final WebSocketFactory wsFactory;

  /**
   * Whether the Requester should retry when a {@link java.net.SocketTimeoutException
   * SocketTimeoutException} occurs.
   */
  protected final boolean retryOnTimeout;

  /**
   * Whether this ShardManager should use {@link net.dv8tion.jda.core.JDA#shutdownNow()
   * JDA#shutdownNow()} instead of {@link net.dv8tion.jda.core.JDA#shutdown() JDA#shutdown()} to
   * shutdown it's shards.
   */
  protected final boolean useShutdownNow;

  /** This can be used to check if the ShardManager is shutting down. */
<span class="nc" id="L144">  protected final AtomicBoolean shutdown = new AtomicBoolean(false);</span>

  /** The shutdown hook used by this ShardManager. If this is null the shutdown hook is disabled. */
  protected final Thread shutdownHook;

  /** The token of the account associated with this ShardManager. */
  protected final String token;

  /**
   * The worker running on the {@link #executor ScheduledExecutorService} that spawns new shards.
   */
  protected Future&lt;?&gt; worker;

  /** The gateway url for JDA to use. Will be {@code nul} until the first shard is created. */
  protected String gatewayURL;

  /** The gameProvider new JDA instances should have on startup. */
  protected IntFunction&lt;Game&gt; gameProvider;

  /** Whether or not new JDA instances should be marked as afk on startup. */
  protected IntFunction&lt;Boolean&gt; idleProvider;

  /** The statusProvider new JDA instances should have on startup. */
  protected IntFunction&lt;OnlineStatus&gt; statusProvider;

  /** The MDC context provider new JDA instances should use on startup. */
  protected IntFunction&lt;ConcurrentMap&lt;String, String&gt;&gt; contextProvider;

  /** Whether to use the MDC context provider. */
  protected boolean enableMDC;

  /**
   * Creates a new DefaultShardManager instance.
   *
   * @param shardsTotal The total amount of shards or {@code -1} to retrieve the recommended amount
   *     from discord.
   * @param shardIds A {@link java.util.Collection Collection} of all shard ids that should be
   *     started in the beginning or {@code null} to start all possible shards. This will be ignored
   *     if shardsTotal is {@code -1}.
   * @param controller The {@link net.dv8tion.jda.core.utils.SessionController SessionController}
   * @param listeners The event listeners for new JDA instances.
   * @param token The token
   * @param eventManager The event manager
   * @param audioSendFactory The {@link net.dv8tion.jda.core.audio.factory.IAudioSendFactory
   *     IAudioSendFactory}
   * @param gameProvider The games used at startup of new JDA instances
   * @param statusProvider The statusProvider used at startup of new JDA instances
   * @param httpClientBuilder The {@link okhttp3.OkHttpClient.Builder OkHttpClient.Builder}
   * @param wsFactory The {@link com.neovisionaries.ws.client.WebSocketFactory WebSocketFactory}
   * @param threadFactory The {@link java.util.concurrent.ThreadFactory ThreadFactory}
   * @param maxReconnectDelay The max reconnect delay
   * @param corePoolSize The core pool size for JDA's internal executor
   * @param enableVoice Whether or not Voice should be enabled
   * @param enableShutdownHook Whether or not the shutdown hook should be enabled
   * @param enableBulkDeleteSplitting Whether or not {@link
   *     net.dv8tion.jda.bot.sharding.DefaultShardManagerBuilder#setBulkDeleteSplittingEnabled(boolean)
   *     bulk delete splitting} should be enabled
   * @param autoReconnect Whether or not auto reconnect should be enabled
   * @param idleProvider The Function that is used to set a shards idle state
   * @param retryOnTimeout hether the Requester should retry when a {@link
   *     java.net.SocketTimeoutException SocketTimeoutException} occurs.
   * @param useShutdownNow Whether the ShardManager should use JDA#shutdown() or not
   * @param enableMDC Whether MDC should be enabled
   * @param contextProvider The MDC context provider new JDA instances should use on startup
   */
  protected DefaultShardManager(
      final int shardsTotal,
      final Collection&lt;Integer&gt; shardIds,
      final SessionController controller,
      final List&lt;Object&gt; listeners,
      final String token,
      final IEventManager eventManager,
      final IntFunction&lt;Game&gt; gameProvider,
      final IntFunction&lt;OnlineStatus&gt; statusProvider,
      final OkHttpClient.Builder httpClientBuilder,
      final WebSocketFactory wsFactory,
      final ThreadFactory threadFactory,
      final int maxReconnectDelay,
      final int corePoolSize,
      final boolean enableVoice,
      final boolean enableShutdownHook,
      final boolean enableBulkDeleteSplitting,
      final boolean autoReconnect,
      final IntFunction&lt;Boolean&gt; idleProvider,
      final boolean retryOnTimeout,
      final boolean useShutdownNow,
      final boolean enableMDC,
<span class="nc" id="L231">      final IntFunction&lt;ConcurrentMap&lt;String, String&gt;&gt; contextProvider) {</span>
<span class="nc" id="L232">    this.shardsTotal = shardsTotal;</span>
<span class="nc" id="L233">    this.listeners = listeners;</span>
<span class="nc" id="L234">    this.token = token;</span>
<span class="nc" id="L235">    this.eventManager = eventManager;</span>
<span class="nc" id="L236">    this.gameProvider = gameProvider;</span>
<span class="nc" id="L237">    this.statusProvider = statusProvider;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">    this.httpClientBuilder =</span>
        httpClientBuilder == null ? new OkHttpClient.Builder() : httpClientBuilder;
<span class="nc bnc" id="L240" title="All 2 branches missed.">    this.wsFactory = wsFactory == null ? new WebSocketFactory() : wsFactory;</span>
<span class="nc" id="L241">    this.executor = createExecutor(threadFactory);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    this.controller = controller == null ? new SessionControllerAdapter() : controller;</span>
<span class="nc" id="L243">    this.maxReconnectDelay = maxReconnectDelay;</span>
<span class="nc" id="L244">    this.corePoolSize = corePoolSize;</span>
<span class="nc" id="L245">    this.enableVoice = enableVoice;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    this.shutdownHook = enableShutdownHook ? new Thread(this::shutdown, &quot;JDA Shutdown Hook&quot;) : null;</span>
<span class="nc" id="L247">    this.enableBulkDeleteSplitting = enableBulkDeleteSplitting;</span>
<span class="nc" id="L248">    this.autoReconnect = autoReconnect;</span>
<span class="nc" id="L249">    this.idleProvider = idleProvider;</span>
<span class="nc" id="L250">    this.retryOnTimeout = retryOnTimeout;</span>
<span class="nc" id="L251">    this.useShutdownNow = useShutdownNow;</span>
<span class="nc" id="L252">    this.contextProvider = contextProvider;</span>
<span class="nc" id="L253">    this.enableMDC = enableMDC;</span>

<span class="nc" id="L255">    synchronized (queue) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (shardsTotal != -1) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (shardIds == null) {</span>
<span class="nc" id="L258">          this.shards = new ShardCacheViewImpl(shardsTotal);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">          for (int i = 0; i &lt; this.shardsTotal; i++) this.queue.add(i);</span>
        } else {
<span class="nc" id="L261">          this.shards = new ShardCacheViewImpl(shardIds.size());</span>
<span class="nc" id="L262">          shardIds.stream().distinct().sorted().forEach(this.queue::add);</span>
        }
      }
<span class="nc" id="L265">    }</span>
<span class="nc" id="L266">  }</span>

  @Override
  public void addEventListener(final Object... listeners) {
<span class="nc" id="L270">    ShardManager.super.addEventListener(listeners);</span>
<span class="nc" id="L271">    Collections.addAll(this.listeners, listeners);</span>
<span class="nc" id="L272">  }</span>

  @Override
  public void removeEventListener(final Object... listeners) {
<span class="nc" id="L276">    ShardManager.super.removeEventListener(listeners);</span>
<span class="nc" id="L277">    this.listeners.removeAll(Arrays.asList(listeners));</span>
<span class="nc" id="L278">  }</span>

  @Override
  public int getShardsQueued() {
<span class="nc" id="L282">    return this.queue.size();</span>
  }

  @Override
  public ShardCacheView getShardCache() {
<span class="nc" id="L287">    return this.shards;</span>
  }

  public void login() throws LoginException {
    // building the first one in the current thread ensures that LoginException and
    // IllegalArgumentException can be thrown on login
<span class="nc" id="L293">    JDAImpl jda = null;</span>
    try {
<span class="nc bnc" id="L295" title="All 2 branches missed.">      final int shardId = this.queue.isEmpty() ? 0 : this.queue.peek();</span>

<span class="nc" id="L297">      jda = this.buildInstance(shardId);</span>
<span class="nc" id="L298">      this.shards.getMap().put(shardId, jda);</span>
<span class="nc" id="L299">      synchronized (queue) {</span>
<span class="nc" id="L300">        this.queue.remove(shardId);</span>
<span class="nc" id="L301">      }</span>
<span class="nc" id="L302">    } catch (final InterruptedException e) {</span>
<span class="nc" id="L303">      LOG.error(&quot;Interrupted Startup&quot;, e);</span>
<span class="nc" id="L304">      throw new IllegalStateException(e);</span>
<span class="nc" id="L305">    } catch (final Exception e) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">      if (jda != null) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (this.useShutdownNow) jda.shutdownNow();</span>
<span class="nc" id="L308">        else jda.shutdown();</span>
      }

<span class="nc" id="L311">      throw e;</span>
<span class="nc" id="L312">    }</span>

<span class="nc" id="L314">    runQueueWorker();</span>
    // this.worker = this.executor.scheduleWithFixedDelay(this::processQueue, 5000, 5000,
    // TimeUnit.MILLISECONDS); // 5s for ratelimit

<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (this.shutdownHook != null) Runtime.getRuntime().addShutdownHook(this.shutdownHook);</span>
<span class="nc" id="L319">  }</span>

  @Override
  public void restart(final int shardId) {
<span class="nc" id="L323">    Checks.notNegative(shardId, &quot;shardId&quot;);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">    Checks.check(shardId &lt; this.shardsTotal, &quot;shardId must be lower than shardsTotal&quot;);</span>

<span class="nc" id="L326">    final JDA jda = this.shards.getMap().remove(shardId);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if (jda != null) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      if (this.useShutdownNow) jda.shutdownNow();</span>
<span class="nc" id="L329">      else jda.shutdown();</span>
    }

<span class="nc" id="L332">    enqueueShard(shardId);</span>
<span class="nc" id="L333">  }</span>

  @Override
  public void restart() {
<span class="nc" id="L337">    TIntObjectMap&lt;JDA&gt; map = this.shards.getMap();</span>
<span class="nc" id="L338">    synchronized (map) {</span>
<span class="nc" id="L339">      Arrays.stream(map.keys())</span>
<span class="nc" id="L340">          .sorted() // this ensures shards are started in natural order</span>
<span class="nc" id="L341">          .forEach(this::restart);</span>
<span class="nc" id="L342">    }</span>
<span class="nc" id="L343">  }</span>

  @Override
  public void shutdown() {
<span class="nc bnc" id="L347" title="All 2 branches missed.">    if (this.shutdown.getAndSet(true)) return; // shutdown has already been requested</span>

<span class="nc bnc" id="L349" title="All 4 branches missed.">    if (this.worker != null &amp;&amp; !this.worker.isDone()) this.worker.cancel(true);</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">    if (this.shutdownHook != null) {</span>
      try {
<span class="nc" id="L353">        Runtime.getRuntime().removeShutdownHook(this.shutdownHook);</span>
<span class="nc" id="L354">      } catch (final Exception ignored) {</span>
<span class="nc" id="L355">      }</span>
    }

<span class="nc" id="L358">    this.executor.shutdown();</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">    if (this.shards != null) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      for (final JDA jda : this.shards) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (this.useShutdownNow) jda.shutdownNow();</span>
<span class="nc" id="L363">        else jda.shutdown();</span>
<span class="nc" id="L364">      }</span>
    }
<span class="nc" id="L366">  }</span>

  @Override
  public void shutdown(final int shardId) {
<span class="nc" id="L370">    final JDA jda = this.shards.getMap().remove(shardId);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    if (jda != null) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">      if (this.useShutdownNow) jda.shutdownNow();</span>
<span class="nc" id="L373">      else jda.shutdown();</span>
    }
<span class="nc" id="L375">  }</span>

  @Override
  public void start(final int shardId) {
<span class="nc" id="L379">    Checks.notNegative(shardId, &quot;shardId&quot;);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">    Checks.check(shardId &lt; this.shardsTotal, &quot;shardId must be lower than shardsTotal&quot;);</span>
<span class="nc" id="L381">    enqueueShard(shardId);</span>
<span class="nc" id="L382">  }</span>

  protected void enqueueShard(final int shardId) {
<span class="nc" id="L385">    synchronized (queue) {</span>
<span class="nc" id="L386">      queue.add(shardId);</span>
<span class="nc" id="L387">      runQueueWorker();</span>
<span class="nc" id="L388">    }</span>
<span class="nc" id="L389">  }</span>

  protected void runQueueWorker() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (worker != null) return;</span>
    try {
<span class="nc" id="L394">      worker =</span>
<span class="nc" id="L395">          executor.submit(</span>
              () -&gt; {
<span class="nc bnc" id="L397" title="All 2 branches missed.">                while (!queue.isEmpty()) processQueue();</span>
<span class="nc" id="L398">                this.gatewayURL = null;</span>
<span class="nc" id="L399">                synchronized (queue) {</span>
<span class="nc" id="L400">                  worker = null;</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">                  if (!shutdown.get() &amp;&amp; !queue.isEmpty()) runQueueWorker();</span>
<span class="nc" id="L402">                }</span>
<span class="nc" id="L403">              });</span>
<span class="nc" id="L404">    } catch (RejectedExecutionException ex) {</span>
<span class="nc" id="L405">      LOG.debug(&quot;ThreadPool rejected queue worker thread&quot;, ex);</span>
<span class="nc" id="L406">    }</span>
<span class="nc" id="L407">  }</span>

  protected void processQueue() {
    int shardId;

<span class="nc bnc" id="L412" title="All 2 branches missed.">    if (this.shards == null) {</span>
<span class="nc" id="L413">      shardId = 0;</span>
    } else {
<span class="nc" id="L415">      Integer tmp = this.queue.peek();</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">      shardId = tmp == null ? -1 : tmp;</span>
    }

<span class="nc bnc" id="L420" title="All 2 branches missed.">    if (shardId == -1) return;</span>

    JDAImpl api;
    try {
<span class="nc bnc" id="L424" title="All 2 branches missed.">      api = this.shards == null ? null : (JDAImpl) this.shards.getElementById(shardId);</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">      if (api == null) api = this.buildInstance(shardId);</span>
<span class="nc" id="L427">    } catch (InterruptedException e) {</span>
      // caused by shutdown
<span class="nc" id="L429">      LOG.debug(&quot;Queue has been interrupted&quot;, e);</span>
<span class="nc" id="L430">      return;</span>
<span class="nc" id="L431">    } catch (LoginException e) {</span>
      // this can only happen if the token has been changed
      // in this case the ShardManager will just shutdown itself as there currently is no way of
      // hot-swapping the token on a running JDA instance.
<span class="nc" id="L435">      LOG.warn(&quot;The token has been invalidated and the ShardManager will shutdown!&quot;, e);</span>
<span class="nc" id="L436">      this.shutdown();</span>
<span class="nc" id="L437">      return;</span>
<span class="nc" id="L438">    } catch (final Exception e) {</span>
<span class="nc" id="L439">      LOG.error(&quot;Caught an exception in the queue processing thread&quot;, e);</span>
<span class="nc" id="L440">      return;</span>
<span class="nc" id="L441">    }</span>

<span class="nc" id="L443">    this.shards.getMap().put(shardId, api);</span>
<span class="nc" id="L444">    synchronized (queue) {</span>
<span class="nc" id="L445">      this.queue.remove(shardId);</span>
<span class="nc" id="L446">    }</span>
<span class="nc" id="L447">  }</span>

  protected JDAImpl buildInstance(final int shardId) throws LoginException, InterruptedException {
<span class="nc bnc" id="L450" title="All 4 branches missed.">    final JDAImpl jda =</span>
        new JDAImpl(
            AccountType.BOT,
            this.token,
            this.controller,
            this.httpClientBuilder,
            this.wsFactory,
            this.autoReconnect,
            this.enableVoice,
            false,
            this.enableBulkDeleteSplitting,
            this.retryOnTimeout,
            this.enableMDC,
            this.corePoolSize,
            this.maxReconnectDelay,
            this.contextProvider == null || !this.enableMDC
                ? null
<span class="nc" id="L467">                : contextProvider.apply(shardId));</span>

<span class="nc" id="L469">    jda.asBot().setShardManager(this);</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">    if (this.eventManager != null) jda.setEventManager(this.eventManager);</span>

<span class="nc" id="L473">    this.listeners.forEach(jda::addEventListener);</span>
<span class="nc" id="L474">    jda.setStatus(</span>
        JDA.Status
            .INITIALIZED); // This is already set by JDA internally, but this is to make sure the
    // listeners catch it.

    // Set the presence information before connecting to have the correct information ready when
    // sending IDENTIFY
<span class="nc" id="L481">    PresenceImpl presence = ((PresenceImpl) jda.getPresence());</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (gameProvider != null) presence.setCacheGame(this.gameProvider.apply(shardId));</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">    if (idleProvider != null) presence.setCacheIdle(this.idleProvider.apply(shardId));</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">    if (statusProvider != null) presence.setCacheStatus(this.statusProvider.apply(shardId));</span>

<span class="nc bnc" id="L486" title="All 2 branches missed.">    if (this.gatewayURL == null) {</span>
      try {
<span class="nc" id="L488">        Pair&lt;String, Integer&gt; gateway = jda.getGatewayBot();</span>
<span class="nc" id="L489">        this.gatewayURL = gateway.getLeft();</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (this.shardsTotal == -1) {</span>
<span class="nc" id="L492">          this.shardsTotal = gateway.getRight();</span>
<span class="nc" id="L493">          this.shards = new ShardCacheViewImpl(this.shardsTotal);</span>

<span class="nc" id="L495">          synchronized (queue) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int i = 0; i &lt; shardsTotal; i++) queue.add(i);</span>
<span class="nc" id="L497">          }</span>
        }
<span class="nc" id="L499">      } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (e.getCause() instanceof InterruptedException) throw (InterruptedException) e.getCause();</span>
        // We check if the LoginException is masked inside of a ExecutionException which is masked
        // inside of the RuntimeException
<span class="nc bnc" id="L503" title="All 2 branches missed.">        Throwable ex = e.getCause() instanceof ExecutionException ? e.getCause().getCause() : null;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (ex instanceof LoginException) throw new LoginException(ex.getMessage());</span>
<span class="nc" id="L505">        else throw e;</span>
<span class="nc" id="L506">      }</span>
    }

<span class="nc" id="L509">    final JDA.ShardInfo shardInfo = new JDA.ShardInfo(shardId, this.shardsTotal);</span>

<span class="nc" id="L511">    final int shardTotal = jda.login(this.gatewayURL, shardInfo);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">    if (this.shardsTotal == -1) this.shardsTotal = shardTotal;</span>

<span class="nc" id="L514">    return jda;</span>
  }

  @Override
  public void setGameProvider(IntFunction&lt;Game&gt; gameProvider) {
<span class="nc" id="L519">    ShardManager.super.setGameProvider(gameProvider);</span>

<span class="nc" id="L521">    this.gameProvider = gameProvider;</span>
<span class="nc" id="L522">  }</span>

  @Override
  public void setIdleProvider(IntFunction&lt;Boolean&gt; idleProvider) {
<span class="nc" id="L526">    ShardManager.super.setIdleProvider(idleProvider);</span>

<span class="nc" id="L528">    this.idleProvider = idleProvider;</span>
<span class="nc" id="L529">  }</span>

  @Override
  public void setStatusProvider(IntFunction&lt;OnlineStatus&gt; statusProvider) {
<span class="nc" id="L533">    ShardManager.super.setStatusProvider(statusProvider);</span>

<span class="nc" id="L535">    this.statusProvider = statusProvider;</span>
<span class="nc" id="L536">  }</span>

  /**
   * This method creates the internal {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService}. It is intended as a hook for custom implementations to create their
   * own executor.
   *
   * @return A new ScheduledExecutorService
   */
  protected ScheduledExecutorService createExecutor(ThreadFactory threadFactory) {
<span class="nc bnc" id="L546" title="All 2 branches missed.">    ThreadFactory factory = threadFactory == null ? DEFAULT_THREAD_FACTORY : threadFactory;</span>

<span class="nc" id="L548">    return Executors.newSingleThreadScheduledExecutor(factory);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>