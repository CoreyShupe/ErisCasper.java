<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShardManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.bot.sharding</a> &gt; <span class="el_source">ShardManager.java</span></div><h1>ShardManager.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.bot.sharding;

import java.util.*;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.stream.Collectors;
import net.dv8tion.jda.bot.entities.ApplicationInfo;
import net.dv8tion.jda.bot.utils.cache.ShardCacheView;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.JDA.Status;
import net.dv8tion.jda.core.OnlineStatus;
import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.requests.RestAction;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.cache.CacheView;
import net.dv8tion.jda.core.utils.cache.SnowflakeCacheView;

/**
 * This class acts as a manager for multiple shards. It contains several methods to make your life
 * with sharding easier. &lt;br&gt;
 * Custom implementations my not support all methods and throw {@link
 * java.lang.UnsupportedOperationException UnsupportedOperationExceptions} instead.
 *
 * @since 3.4
 * @author Aljoscha Grebe
 */
public interface ShardManager {
  /**
   * Adds all provided listeners to the event-listeners that will be used to handle events.
   *
   * &lt;p&gt;Note: when using the {@link net.dv8tion.jda.core.hooks.InterfacedEventManager
   * InterfacedEventListener} (default), given listener &lt;b&gt;must&lt;/b&gt; be instance of {@link
   * net.dv8tion.jda.core.hooks.EventListener EventListener}!
   *
   * @param listeners The listener(s) which will react to events.
   * @throws java.lang.IllegalArgumentException If either listeners or one of it's objects is {@code
   *     null}.
   */
  default void addEventListener(final Object... listeners) {
<span class="nc" id="L56">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>
<span class="nc" id="L57">    this.getShardCache().forEach(jda -&gt; jda.addEventListener(listeners));</span>
<span class="nc" id="L58">  }</span>

  /**
   * Removes all provided listeners from the event-listeners and no longer uses them to handle
   * events.
   *
   * @param listeners The listener(s) to be removed.
   * @throws java.lang.IllegalArgumentException If either listeners or one of it's objects is {@code
   *     null}.
   */
  default void removeEventListener(final Object... listeners) {
<span class="nc" id="L69">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>
<span class="nc" id="L70">    this.getShardCache().forEach(jda -&gt; jda.removeEventListener(listeners));</span>
<span class="nc" id="L71">  }</span>

  /**
   * Returns the amount of shards queued for (re)connecting.
   *
   * @return The amount of shards queued for (re)connecting.
   */
  int getShardsQueued();

  /**
   * Returns the amount of running shards.
   *
   * @return The amount of running shards.
   */
  default int getShardsRunning() {
<span class="nc" id="L86">    return (int) this.getShardCache().size();</span>
  }

  /**
   * Returns the amount of shards managed by this {@link net.dv8tion.jda.bot.sharding.ShardManager
   * ShardManager}. This includes shards currently queued for a restart.
   *
   * @return The managed amount of shards.
   */
  default int getShardsTotal() {
<span class="nc" id="L96">    return this.getShardsQueued() + this.getShardsRunning();</span>
  }

  /**
   * Used to access Bot specific functions like OAuth information.
   *
   * @throws java.lang.IllegalStateException If there is no running shard
   * @return The {@link net.dv8tion.jda.bot.JDABot} registry for this instance of JDA.
   */
  default RestAction&lt;ApplicationInfo&gt; getApplicationInfo() {
<span class="nc" id="L106">    return this.getShardCache()</span>
<span class="nc" id="L107">        .stream()</span>
<span class="nc" id="L108">        .findAny()</span>
<span class="nc" id="L109">        .orElseThrow(() -&gt; new IllegalStateException(&quot;no active shards&quot;))</span>
<span class="nc" id="L110">        .asBot()</span>
<span class="nc" id="L111">        .getApplicationInfo();</span>
  }

  /**
   * The average time in milliseconds between all shards that discord took to respond to our last
   * heartbeat. This roughly represents the WebSocket ping of this session. If there is no shard
   * running this wil return {@code -1}.
   *
   * &lt;p&gt;&lt;b&gt;{@link net.dv8tion.jda.core.requests.RestAction RestAction} request times do not
   * correlate to this value!&lt;/b&gt;
   *
   * @return The average time in milliseconds between heartbeat and the heartbeat ack response
   */
  default double getAveragePing() {
<span class="nc" id="L125">    return this.getShardCache()</span>
<span class="nc" id="L126">        .stream()</span>
<span class="nc" id="L127">        .mapToLong(JDA::getPing)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        .filter(ping -&gt; ping != -1)</span>
<span class="nc" id="L129">        .average()</span>
<span class="nc" id="L130">        .orElse(-1D);</span>
  }

  /**
   * Gets all {@link net.dv8tion.jda.core.entities.Category Categories} visible to the currently
   * logged in account.
   *
   * @return An immutable list of all visible {@link net.dv8tion.jda.core.entities.Category
   *     Categories}.
   */
  default List&lt;Category&gt; getCategories() {
<span class="nc" id="L141">    return this.getCategoryCache().asList();</span>
  }

  /**
   * Gets a list of all {@link net.dv8tion.jda.core.entities.Category Categories} that have the same
   * name as the one provided. &lt;br&gt;
   * If there are no matching categories this will return an empty list.
   *
   * @param name The name to check
   * @param ignoreCase Whether to ignore case on name checking
   * @return Immutable list of all categories matching the provided name
   * @throws java.lang.IllegalArgumentException If the provided name is {@code null}
   */
  default List&lt;Category&gt; getCategoriesByName(final String name, final boolean ignoreCase) {
<span class="nc" id="L155">    return this.getCategoryCache().getElementsByName(name, ignoreCase);</span>
  }

  /**
   * Gets the {@link net.dv8tion.jda.core.entities.Category Category} that matches the provided id.
   * &lt;br&gt;
   * If there is no matching {@link net.dv8tion.jda.core.entities.Category Category} this returns
   * {@code null}.
   *
   * @param id The snowflake ID of the wanted Category
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Category Category} for the provided
   *     ID.
   */
  default Category getCategoryById(final long id) {
<span class="nc" id="L169">    return this.getCategoryCache().getElementById(id);</span>
  }

  /**
   * Gets the {@link net.dv8tion.jda.core.entities.Category Category} that matches the provided id.
   * &lt;br&gt;
   * If there is no matching {@link net.dv8tion.jda.core.entities.Category Category} this returns
   * {@code null}.
   *
   * @param id The snowflake ID of the wanted Category
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Category Category} for the provided
   *     ID.
   * @throws java.lang.IllegalArgumentException If the provided ID is not a valid {@code long}
   */
  default Category getCategoryById(final String id) {
<span class="nc" id="L184">    return this.getCategoryCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.Category Categories} visible to this ShardManager
   * instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;Category&gt; getCategoryCache() {
<span class="nc" id="L195">    return CacheView.allSnowflakes(() -&gt; this.getShardCache().stream().map(JDA::getCategoryCache));</span>
  }

  /**
   * Retrieves an emote matching the specified {@code id} if one is available in our cache.
   *
   * &lt;p&gt;&lt;b&gt;Unicode emojis are not included as {@link net.dv8tion.jda.core.entities.Emote Emote}!&lt;/b&gt;
   *
   * @param id The id of the requested {@link net.dv8tion.jda.core.entities.Emote}.
   * @return An {@link net.dv8tion.jda.core.entities.Emote Emote} represented by this id or null if
   *     none is found in our cache.
   */
  default Emote getEmoteById(final long id) {
<span class="nc" id="L208">    return this.getEmoteCache().getElementById(id);</span>
  }

  /**
   * Retrieves an emote matching the specified {@code id} if one is available in our cache.
   *
   * &lt;p&gt;&lt;b&gt;Unicode emojis are not included as {@link net.dv8tion.jda.core.entities.Emote Emote}!&lt;/b&gt;
   *
   * @param id The id of the requested {@link net.dv8tion.jda.core.entities.Emote}.
   * @return An {@link net.dv8tion.jda.core.entities.Emote Emote} represented by this id or null if
   *     none is found in our cache.
   * @throws java.lang.NumberFormatException If the provided {@code id} cannot be parsed by {@link
   *     Long#parseLong(String)}
   */
  default Emote getEmoteById(final String id) {
<span class="nc" id="L223">    return this.getEmoteCache().getElementById(id);</span>
  }

  /**
   * Unified {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all
   * cached {@link net.dv8tion.jda.core.entities.Emote Emotes} visible to this ShardManager
   * instance.
   *
   * @return Unified {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;Emote&gt; getEmoteCache() {
<span class="nc" id="L234">    return CacheView.allSnowflakes(() -&gt; this.getShardCache().stream().map(JDA::getEmoteCache));</span>
  }

  /**
   * A collection of all to us known emotes (managed/restricted included).
   *
   * &lt;p&gt;&lt;b&gt;Hint&lt;/b&gt;: To check whether you can use an {@link net.dv8tion.jda.core.entities.Emote
   * Emote} in a specific context you can use {@link
   * Emote#canInteract(net.dv8tion.jda.core.entities.Member)} or {@link
   * Emote#canInteract(net.dv8tion.jda.core.entities.User,
   * net.dv8tion.jda.core.entities.MessageChannel)}
   *
   * &lt;p&gt;&lt;b&gt;Unicode emojis are not included as {@link net.dv8tion.jda.core.entities.Emote Emote}!&lt;/b&gt;
   *
   * @return An immutable list of Emotes (which may or may not be available to usage).
   */
  default List&lt;Emote&gt; getEmotes() {
<span class="nc" id="L251">    return this.getEmoteCache().asList();</span>
  }

  /**
   * An unmodifiable list of all {@link net.dv8tion.jda.core.entities.Emote Emotes} that have the
   * same name as the one provided. &lt;br&gt;
   * If there are no {@link net.dv8tion.jda.core.entities.Emote Emotes} with the provided name, then
   * this returns an empty list.
   *
   * &lt;p&gt;&lt;b&gt;Unicode emojis are not included as {@link net.dv8tion.jda.core.entities.Emote Emote}!&lt;/b&gt;
   *
   * @param name The name of the requested {@link net.dv8tion.jda.core.entities.Emote Emotes}.
   * @param ignoreCase Whether to ignore case or not when comparing the provided name to each {@link
   *     net.dv8tion.jda.core.entities.Emote#getName()}.
   * @return Possibly-empty list of all the {@link net.dv8tion.jda.core.entities.Emote Emotes} that
   *     all have the same name as the provided name.
   */
  default List&lt;Emote&gt; getEmotesByName(final String name, final boolean ignoreCase) {
<span class="nc" id="L269">    return this.getEmoteCache().getElementsByName(name, ignoreCase);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.Guild Guild} which has the same id as the
   * one provided. &lt;br&gt;
   * If there is no connected guild with an id that matches the provided one, then this returns
   * {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.Guild Guild}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Guild Guild} with matching id.
   */
  default Guild getGuildById(final long id) {
<span class="nc" id="L282">    return this.getGuildCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.Guild Guild} which has the same id as the
   * one provided. &lt;br&gt;
   * If there is no connected guild with an id that matches the provided one, then this returns
   * {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.Guild Guild}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Guild Guild} with matching id.
   */
  default Guild getGuildById(final String id) {
<span class="nc" id="L295">    return this.getGuildCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.Guild Guilds} visible to this ShardManager instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;Guild&gt; getGuildCache() {
<span class="nc" id="L305">    return CacheView.allSnowflakes(() -&gt; this.getShardCache().stream().map(JDA::getGuildCache));</span>
  }
  /**
   * An unmodifiable List of all {@link net.dv8tion.jda.core.entities.Guild Guilds} that the logged
   * account is connected to. &lt;br&gt;
   * If this account is not connected to any {@link net.dv8tion.jda.core.entities.Guild Guilds},
   * this will return an empty list.
   *
   * @return Possibly-empty list of all the {@link net.dv8tion.jda.core.entities.Guild Guilds} that
   *     this account is connected to.
   */
  default List&lt;Guild&gt; getGuilds() {
<span class="nc" id="L317">    return this.getGuildCache().asList();</span>
  }

  /**
   * Gets all {@link net.dv8tion.jda.core.entities.Guild Guilds} that contain all given users as
   * their members.
   *
   * @param users The users which all the returned {@link net.dv8tion.jda.core.entities.Guild
   *     Guilds} must contain.
   * @return Unmodifiable list of all {@link net.dv8tion.jda.core.entities.Guild Guild} instances
   *     which have all {@link net.dv8tion.jda.core.entities.User Users} in them.
   */
  default List&lt;Guild&gt; getMutualGuilds(final Collection&lt;User&gt; users) {
<span class="nc" id="L330">    Checks.noneNull(users, &quot;users&quot;);</span>
<span class="nc" id="L331">    return Collections.unmodifiableList(</span>
<span class="nc" id="L332">        this.getGuildCache()</span>
<span class="nc" id="L333">            .stream()</span>
<span class="nc" id="L334">            .filter(guild -&gt; users.stream().allMatch(guild::isMember))</span>
<span class="nc" id="L335">            .collect(Collectors.toList()));</span>
  }

  /**
   * Gets all {@link net.dv8tion.jda.core.entities.Guild Guilds} that contain all given users as
   * their members.
   *
   * @param users The users which all the returned {@link net.dv8tion.jda.core.entities.Guild
   *     Guilds} must contain.
   * @return Unmodifiable list of all {@link net.dv8tion.jda.core.entities.Guild Guild} instances
   *     which have all {@link net.dv8tion.jda.core.entities.User Users} in them.
   */
  default List&lt;Guild&gt; getMutualGuilds(final User... users) {
<span class="nc" id="L348">    Checks.notNull(users, &quot;users&quot;);</span>
<span class="nc" id="L349">    return this.getMutualGuilds(Arrays.asList(users));</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} which has
   * the same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} with
   * an id that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} with
   *     matching id.
   */
  default PrivateChannel getPrivateChannelById(final long id) {
<span class="nc" id="L363">    return this.getPrivateChannelCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} which has
   * the same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} with
   * an id that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel}.
   * @throws java.lang.NumberFormatException If the provided {@code id} cannot be parsed by {@link
   *     Long#parseLong(String)}
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannel} with
   *     matching id.
   */
  default PrivateChannel getPrivateChannelById(final String id) {
<span class="nc" id="L379">    return this.getPrivateChannelCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.PrivateChannel PrivateChannels} visible to this
   * ShardManager instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;PrivateChannel&gt; getPrivateChannelCache() {
<span class="nc" id="L390">    return CacheView.allSnowflakes(</span>
<span class="nc" id="L391">        () -&gt; this.getShardCache().stream().map(JDA::getPrivateChannelCache));</span>
  }

  /**
   * An unmodifiable list of all known {@link net.dv8tion.jda.core.entities.PrivateChannel
   * PrivateChannels}.
   *
   * @return Possibly-empty list of all {@link net.dv8tion.jda.core.entities.PrivateChannel
   *     PrivateChannels}.
   */
  default List&lt;PrivateChannel&gt; getPrivateChannels() {
<span class="nc" id="L402">    return this.getPrivateChannelCache().asList();</span>
  }

  /**
   * Retrieves the {@link net.dv8tion.jda.core.entities.Role Role} associated to the provided id.
   * &lt;br&gt;
   * This iterates over all {@link net.dv8tion.jda.core.entities.Guild Guilds} and check whether a
   * Role from that Guild is assigned to the specified ID and will return the first that can be
   * found.
   *
   * @param id The id of the searched Role
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Role Role} for the specified ID
   */
  default Role getRoleById(final long id) {
<span class="nc" id="L416">    return this.getRoleCache().getElementById(id);</span>
  }

  /**
   * Retrieves the {@link net.dv8tion.jda.core.entities.Role Role} associated to the provided id.
   * &lt;br&gt;
   * This iterates over all {@link net.dv8tion.jda.core.entities.Guild Guilds} and check whether a
   * Role from that Guild is assigned to the specified ID and will return the first that can be
   * found.
   *
   * @param id The id of the searched Role
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.Role Role} for the specified ID
   * @throws java.lang.NumberFormatException If the provided {@code id} cannot be parsed by {@link
   *     Long#parseLong(String)}
   */
  default Role getRoleById(final String id) {
<span class="nc" id="L432">    return this.getRoleCache().getElementById(id);</span>
  }

  /**
   * Unified {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all
   * cached {@link net.dv8tion.jda.core.entities.Role Roles} visible to this ShardManager instance.
   *
   * @return Unified {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;Role&gt; getRoleCache() {
<span class="nc" id="L442">    return CacheView.allSnowflakes(() -&gt; this.getShardCache().stream().map(JDA::getRoleCache));</span>
  }

  /**
   * All {@link net.dv8tion.jda.core.entities.Role Roles} this ShardManager instance can see. &lt;br&gt;
   * This will iterate over each {@link net.dv8tion.jda.core.entities.Guild Guild} retrieved from
   * {@link #getGuilds()} and collect its {@link net.dv8tion.jda.core.entities.Guild#getRoles()
   * Guild.getRoles()}.
   *
   * @return Immutable List of all visible Roles
   */
  default List&lt;Role&gt; getRoles() {
<span class="nc" id="L454">    return this.getRoleCache().asList();</span>
  }

  /**
   * Retrieves all {@link net.dv8tion.jda.core.entities.Role Roles} visible to this ShardManager
   * instance. &lt;br&gt;
   * This simply filters the Roles returned by {@link #getRoles()} with the provided name, either
   * using {@link String#equals(Object)} or {@link String#equalsIgnoreCase(String)} on {@link
   * net.dv8tion.jda.core.entities.Role#getName()}.
   *
   * @param name The name for the Roles
   * @param ignoreCase Whether to use {@link String#equalsIgnoreCase(String)}
   * @return Immutable List of all Roles matching the parameters provided.
   */
  default List&lt;Role&gt; getRolesByName(final String name, final boolean ignoreCase) {
<span class="nc" id="L469">    return this.getRoleCache().getElementsByName(name, ignoreCase);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.JDA JDA} instance which has the same id as the one
   * provided. &lt;br&gt;
   * If there is no shard with an id that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the shard.
   * @return The {@link net.dv8tion.jda.core.JDA JDA} instance with the given shardId or {@code
   *     null} if no shard has the given id
   */
  default JDA getShardById(final int id) {
<span class="nc" id="L482">    return this.getShardCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.JDA JDA} instance which has the same id as the one
   * provided. &lt;br&gt;
   * If there is no shard with an id that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the shard.
   * @return The {@link net.dv8tion.jda.core.JDA JDA} instance with the given shardId or {@code
   *     null} if no shard has the given id
   */
  default JDA getShardById(final String id) {
<span class="nc" id="L495">    return this.getShardCache().getElementById(id);</span>
  }

  /**
   * Unified {@link net.dv8tion.jda.bot.utils.cache.ShardCacheView ShardCacheView} of all cached
   * {@link net.dv8tion.jda.core.JDA JDA} bound to this ShardManager instance.
   *
   * @return Unified {@link net.dv8tion.jda.bot.utils.cache.ShardCacheView ShardCacheView}
   */
  ShardCacheView getShardCache();

  /**
   * Gets all {@link net.dv8tion.jda.core.JDA JDA} instances bound to this ShardManager.
   *
   * @return An immutable list of all managed {@link net.dv8tion.jda.core.JDA JDA} instances.
   */
  default List&lt;JDA&gt; getShards() {
<span class="nc" id="L512">    return this.getShardCache().asList();</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.JDA.Status JDA.Status} of the shard which has the
   * same id as the one provided. &lt;br&gt;
   * If there is no shard with an id that matches the provided one, then this returns {@code null}.
   *
   * @param shardId The id of the shard.
   * @return The {@link net.dv8tion.jda.core.JDA.Status JDA.Status} of the shard with the given
   *     shardId or {@code null} if no shard has the given id
   */
  default JDA.Status getStatus(final int shardId) {
<span class="nc" id="L525">    final JDA jda = this.getShardCache().getElementById(shardId);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">    return jda == null ? null : jda.getStatus();</span>
  }

  /**
   * Gets the current {@link net.dv8tion.jda.core.JDA.Status Status} of all shards.
   *
   * @return All current shard statuses.
   */
  default Map&lt;JDA, Status&gt; getStatuses() {
<span class="nc" id="L535">    return Collections.unmodifiableMap(</span>
<span class="nc" id="L536">        this.getShardCache()</span>
<span class="nc" id="L537">            .stream()</span>
<span class="nc" id="L538">            .collect(Collectors.toMap(Function.identity(), JDA::getStatus)));</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} which has the
   * same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} with an id
   * that matches the provided one, then this returns {@code null}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; just because a {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} is
   * present does not mean that you will be able to send messages to it. Furthermore, if you log
   * into this account on the discord client, it is you will not see the channel that this returns.
   * This is because the discord client hides any {@link net.dv8tion.jda.core.entities.TextChannel
   * TextChannel} that you don't have the {@link net.dv8tion.jda.core.Permission#MESSAGE_READ
   * Permission.MESSAGE_READ} permission in.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} with
   *     matching id.
   */
  default TextChannel getTextChannelById(final long id) {
<span class="nc" id="L559">    return this.getTextChannelCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} which has the
   * same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} with an id
   * that matches the provided one, then this returns {@code null}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; just because a {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} is
   * present does not mean that you will be able to send messages to it. Furthermore, if you log
   * into this account on the discord client, it is you will not see the channel that this returns.
   * This is because the discord client hides any {@link net.dv8tion.jda.core.entities.TextChannel
   * TextChannel} that you don't have the {@link net.dv8tion.jda.core.Permission#MESSAGE_READ
   * Permission.MESSAGE_READ} permission in.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} with
   *     matching id.
   */
  default TextChannel getTextChannelById(final String id) {
<span class="nc" id="L580">    return this.getTextChannelCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.TextChannel TextChannels} visible to this ShardManager
   * instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;TextChannel&gt; getTextChannelCache() {
<span class="nc" id="L591">    return CacheView.allSnowflakes(</span>
<span class="nc" id="L592">        () -&gt; this.getShardCache().stream().map(JDA::getTextChannelCache));</span>
  }

  /**
   * An unmodifiable List of all {@link net.dv8tion.jda.core.entities.TextChannel TextChannels} of
   * all connected {@link net.dv8tion.jda.core.entities.Guild Guilds}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; just because a {@link net.dv8tion.jda.core.entities.TextChannel TextChannel} is
   * present in this list does not mean that you will be able to send messages to it. Furthermore,
   * if you log into this account on the discord client, it is possible that you will see fewer
   * channels than this returns. This is because the discord client hides any {@link
   * net.dv8tion.jda.core.entities.TextChannel TextChannel} that you don't have the {@link
   * net.dv8tion.jda.core.Permission#MESSAGE_READ Permission.MESSAGE_READ} permission in.
   *
   * @return Possibly-empty list of all known {@link net.dv8tion.jda.core.entities.TextChannel
   *     TextChannels}.
   */
  default List&lt;TextChannel&gt; getTextChannels() {
<span class="nc" id="L610">    return this.getTextChannelCache().asList();</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.User User} which has the same id as the
   * one provided. &lt;br&gt;
   * If there is no visible user with an id that matches the provided one, this returns {@code
   * null}.
   *
   * @param id The id of the requested {@link net.dv8tion.jda.core.entities.User User}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.User User} with matching id.
   */
  default User getUserById(final long id) {
<span class="nc" id="L623">    return this.getUserCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.User User} which has the same id as the
   * one provided. &lt;br&gt;
   * If there is no visible user with an id that matches the provided one, this returns {@code
   * null}.
   *
   * @param id The id of the requested {@link net.dv8tion.jda.core.entities.User User}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.User User} with matching id.
   */
  default User getUserById(final String id) {
<span class="nc" id="L636">    return this.getUserCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.User Users} visible to this ShardManager instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;User&gt; getUserCache() {
<span class="nc" id="L646">    return CacheView.allSnowflakes(() -&gt; this.getShardCache().stream().map(JDA::getUserCache));</span>
  }

  /**
   * An unmodifiable list of all {@link net.dv8tion.jda.core.entities.User Users} that share a
   * {@link net.dv8tion.jda.core.entities.Guild Guild} with the currently logged in account. &lt;br&gt;
   * This list will never contain duplicates and represents all {@link
   * net.dv8tion.jda.core.entities.User Users} that JDA can currently see.
   *
   * &lt;p&gt;If the developer is sharding, then only users from guilds connected to the specifically
   * logged in shard will be returned in the List.
   *
   * @return List of all {@link net.dv8tion.jda.core.entities.User Users} that are visible to JDA.
   */
  default List&lt;User&gt; getUsers() {
<span class="nc" id="L661">    return this.getUserCache().asList();</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} which has the
   * same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} with an id
   * that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} with
   *     matching id.
   */
  default VoiceChannel getVoiceChannelById(final long id) {
<span class="nc" id="L675">    return this.getVoiceChannelCache().getElementById(id);</span>
  }

  /**
   * This returns the {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} which has the
   * same id as the one provided. &lt;br&gt;
   * If there is no known {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} with an id
   * that matches the provided one, then this returns {@code null}.
   *
   * @param id The id of the {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel}.
   * @return Possibly-null {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannel} with
   *     matching id.
   */
  default VoiceChannel getVoiceChannelById(final String id) {
<span class="nc" id="L689">    return this.getVoiceChannelCache().getElementById(id);</span>
  }

  /**
   * {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView} of all cached
   * {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannels} visible to this ShardManager
   * instance.
   *
   * @return {@link net.dv8tion.jda.core.utils.cache.SnowflakeCacheView SnowflakeCacheView}
   */
  default SnowflakeCacheView&lt;VoiceChannel&gt; getVoiceChannelCache() {
<span class="nc" id="L700">    return CacheView.allSnowflakes(</span>
<span class="nc" id="L701">        () -&gt; this.getShardCache().stream().map(JDA::getVoiceChannelCache));</span>
  }

  /**
   * An unmodifiable list of all {@link net.dv8tion.jda.core.entities.VoiceChannel VoiceChannels} of
   * all connected {@link net.dv8tion.jda.core.entities.Guild Guilds}.
   *
   * @return Possible-empty list of all known {@link net.dv8tion.jda.core.entities.VoiceChannel
   *     VoiceChannels}.
   */
  default List&lt;VoiceChannel&gt; getVoiceChannels() {
<span class="nc" id="L712">    return this.getVoiceChannelCache().asList();</span>
  }

  /**
   * Restarts all shards, shutting old ones down first.
   *
   * &lt;p&gt;As all shards need to connect to discord again this will take equally long as the startup of
   * a new ShardManager (using the 5000ms + backoff as delay between starting new JDA instances).
   */
  void restart();

  /**
   * Restarts the shards with the given id only. &lt;br&gt;
   * If there is no shard with the given Id this method acts like {@link #start(int)}.
   *
   * @param id The id of the target shard
   * @throws IllegalArgumentException if shardId is negative or higher than maxShardId
   */
  void restart(int id);

  /**
   * Sets the {@link net.dv8tion.jda.core.entities.Game Game} for all shards. &lt;br&gt;
   * A Game can be retrieved via {@link net.dv8tion.jda.core.entities.Game#playing(String)}. For
   * streams you provide a valid streaming url as second parameter.
   *
   * &lt;p&gt;This will also change the game for shards that are created in the future.
   *
   * @param game A {@link net.dv8tion.jda.core.entities.Game Game} instance or null to reset
   * @see net.dv8tion.jda.core.entities.Game#playing(String)
   * @see net.dv8tion.jda.core.entities.Game#streaming(String, String)
   */
  default void setGame(final Game game) {
<span class="nc" id="L744">    this.setGameProvider(id -&gt; game);</span>
<span class="nc" id="L745">  }</span>

  /**
   * Sets provider that provider the {@link net.dv8tion.jda.core.entities.Game Game} for all shards.
   * &lt;br&gt;
   * A Game can be retrieved via {@link net.dv8tion.jda.core.entities.Game#playing(String)}. For
   * streams you provide a valid streaming url as second parameter.
   *
   * &lt;p&gt;This will also change the provider for shards that are created in the future.
   *
   * @param gameProvider A {@link net.dv8tion.jda.core.entities.Game Game} instance or null to reset
   * @see net.dv8tion.jda.core.entities.Game#playing(String)
   * @see net.dv8tion.jda.core.entities.Game#streaming(String, String)
   */
  default void setGameProvider(final IntFunction&lt;Game&gt; gameProvider) {
<span class="nc" id="L760">    this.getShardCache()</span>
<span class="nc" id="L761">        .forEach(</span>
<span class="nc" id="L762">            jda -&gt; jda.getPresence().setGame(gameProvider.apply(jda.getShardInfo().getShardId())));</span>
<span class="nc" id="L763">  }</span>

  /**
   * Sets whether all instances should be marked as afk or not
   *
   * &lt;p&gt;This is relevant to client accounts to monitor whether new messages should trigger mobile
   * push-notifications.
   *
   * &lt;p&gt;This will also change the value for shards that are created in the future.
   *
   * @param idle boolean
   */
  default void setIdle(final boolean idle) {
<span class="nc" id="L776">    this.setIdleProvider(id -&gt; idle);</span>
<span class="nc" id="L777">  }</span>

  /**
   * Sets the provider that decides for all shards whether they should be marked as afk or not.
   *
   * &lt;p&gt;This will also change the provider for shards that are created in the future.
   *
   * @param idleProvider boolean
   */
  default void setIdleProvider(final IntFunction&lt;Boolean&gt; idleProvider) {
<span class="nc" id="L787">    this.getShardCache()</span>
<span class="nc" id="L788">        .forEach(</span>
<span class="nc" id="L789">            jda -&gt; jda.getPresence().setIdle(idleProvider.apply(jda.getShardInfo().getShardId())));</span>
<span class="nc" id="L790">  }</span>

  /**
   * Sets the {@link net.dv8tion.jda.core.OnlineStatus OnlineStatus} for all shards.
   *
   * &lt;p&gt;This will also change the status for shards that are created in the future.
   *
   * @throws IllegalArgumentException if the provided OnlineStatus is {@link
   *     net.dv8tion.jda.core.OnlineStatus#UNKNOWN UNKNOWN}
   * @param status the {@link net.dv8tion.jda.core.OnlineStatus OnlineStatus} to be used
   *     (OFFLINE/null {@literal -&gt;} INVISIBLE)
   */
  default void setStatus(final OnlineStatus status) {
<span class="nc" id="L803">    this.setStatusProvider(id -&gt; status);</span>
<span class="nc" id="L804">  }</span>

  /**
   * Sets the provider that provides the {@link net.dv8tion.jda.core.OnlineStatus OnlineStatus} for
   * all shards.
   *
   * &lt;p&gt;This will also change the provider for shards that are created in the future.
   *
   * @throws IllegalArgumentException if the provided OnlineStatus is {@link
   *     net.dv8tion.jda.core.OnlineStatus#UNKNOWN UNKNOWN}
   * @param statusProvider the {@link net.dv8tion.jda.core.OnlineStatus OnlineStatus} to be used
   *     (OFFLINE/null {@literal -&gt;} INVISIBLE)
   */
  default void setStatusProvider(final IntFunction&lt;OnlineStatus&gt; statusProvider) {
<span class="nc" id="L818">    this.getShardCache()</span>
<span class="nc" id="L819">        .forEach(</span>
            jda -&gt;
<span class="nc" id="L821">                jda.getPresence().setStatus(statusProvider.apply(jda.getShardInfo().getShardId())));</span>
<span class="nc" id="L822">  }</span>

  /**
   * Shuts down all JDA shards, closing all their connections. After this method has been called the
   * ShardManager instance can not be used anymore.
   */
  void shutdown();

  /**
   * Shuts down the shard with the given id only. &lt;br&gt;
   * This does nothing if there is no shard with the given id.
   *
   * @param shardId The id of the shard that should be stopped
   */
  void shutdown(int shardId);

  /**
   * Adds a new shard with the given id to this ShardManager and starts it.
   *
   * @param shardId The id of the shard that should be started
   */
  void start(int shardId);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>