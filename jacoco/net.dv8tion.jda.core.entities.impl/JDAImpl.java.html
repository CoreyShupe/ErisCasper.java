<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDAImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.entities.impl</a> &gt; <span class="el_source">JDAImpl.java</span></div><h1>JDAImpl.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.entities.impl;

import com.neovisionaries.ws.client.WebSocketFactory;
import gnu.trove.map.TLongObjectMap;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import javax.security.auth.login.LoginException;
import net.dv8tion.jda.bot.entities.impl.JDABotImpl;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.audio.AudioWebSocket;
import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.events.StatusChangeEvent;
import net.dv8tion.jda.core.exceptions.AccountTypeException;
import net.dv8tion.jda.core.exceptions.RateLimitedException;
import net.dv8tion.jda.core.handle.EventCache;
import net.dv8tion.jda.core.hooks.IEventManager;
import net.dv8tion.jda.core.hooks.InterfacedEventManager;
import net.dv8tion.jda.core.managers.AudioManager;
import net.dv8tion.jda.core.managers.Presence;
import net.dv8tion.jda.core.managers.impl.PresenceImpl;
import net.dv8tion.jda.core.requests.*;
import net.dv8tion.jda.core.requests.restaction.GuildAction;
import net.dv8tion.jda.core.utils.*;
import net.dv8tion.jda.core.utils.cache.CacheView;
import net.dv8tion.jda.core.utils.cache.SnowflakeCacheView;
import net.dv8tion.jda.core.utils.cache.impl.AbstractCacheView;
import net.dv8tion.jda.core.utils.cache.impl.SnowflakeCacheViewImpl;
import net.dv8tion.jda.core.utils.tuple.Pair;
import okhttp3.OkHttpClient;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JDAImpl implements JDA {
<span class="nc" id="L52">  public static final Logger LOG = LoggerFactory.getLogger(JDA.class);</span>

  public final ScheduledThreadPoolExecutor pool;

<span class="nc" id="L56">  protected final SnowflakeCacheViewImpl&lt;User&gt; userCache =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(User::getName);
<span class="nc" id="L58">  protected final SnowflakeCacheViewImpl&lt;Guild&gt; guildCache =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(Guild::getName);
<span class="nc" id="L60">  protected final SnowflakeCacheViewImpl&lt;Category&gt; categories =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(Channel::getName);
<span class="nc" id="L62">  protected final SnowflakeCacheViewImpl&lt;TextChannel&gt; textChannelCache =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(Channel::getName);
<span class="nc" id="L64">  protected final SnowflakeCacheViewImpl&lt;VoiceChannel&gt; voiceChannelCache =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(Channel::getName);
<span class="nc" id="L66">  protected final SnowflakeCacheViewImpl&lt;PrivateChannel&gt; privateChannelCache =</span>
      new SnowflakeCacheViewImpl&lt;&gt;(MessageChannel::getName);

<span class="nc" id="L69">  protected final TLongObjectMap&lt;User&gt; fakeUsers = MiscUtil.newLongMap();</span>
<span class="nc" id="L70">  protected final TLongObjectMap&lt;PrivateChannel&gt; fakePrivateChannels = MiscUtil.newLongMap();</span>

<span class="nc" id="L72">  protected final AbstractCacheView&lt;AudioManager&gt; audioManagers =</span>
<span class="nc" id="L73">      new CacheView.SimpleCacheView&lt;&gt;(m -&gt; m.getGuild().getName());</span>

  protected final ConcurrentMap&lt;String, String&gt; contextMap;
  protected final OkHttpClient.Builder httpClientBuilder;
  protected final WebSocketFactory wsFactory;
  protected final PresenceImpl presence;
  protected final JDABotImpl jdaBot;
  protected final int maxReconnectDelay;
  protected final Thread shutdownHook;
<span class="nc" id="L82">  protected final EntityBuilder entityBuilder = new EntityBuilder(this);</span>
<span class="nc" id="L83">  protected final EventCache eventCache = new EventCache();</span>
<span class="nc" id="L84">  protected final GuildLock guildLock = new GuildLock(this);</span>
<span class="nc" id="L85">  protected final Object akapLock = new Object();</span>

  protected final SessionController sessionController;

  protected WebSocketClient client;
  protected Requester requester;
<span class="nc" id="L91">  protected IEventManager eventManager = new InterfacedEventManager();</span>
  protected ScheduledThreadPoolExecutor audioKeepAlivePool;
<span class="nc" id="L93">  protected Status status = Status.INITIALIZING;</span>
  protected SelfUser selfUser;
  protected ShardInfo shardInfo;
  protected boolean audioEnabled;
  protected boolean bulkDeleteSplittingEnabled;
  protected boolean autoReconnect;
  protected long responseTotal;
<span class="nc" id="L100">  protected long ping = -1;</span>
  protected String token;
  protected String gatewayUrl;

  public JDAImpl(
      String token,
      SessionController controller,
      OkHttpClient.Builder httpClientBuilder,
      WebSocketFactory wsFactory,
      boolean autoReconnect,
      boolean audioEnabled,
      boolean useShutdownHook,
      boolean bulkDeleteSplittingEnabled,
      boolean retryOnTimeout,
      boolean enableMDC,
      int corePoolSize,
      int maxReconnectDelay,
<span class="nc" id="L117">      ConcurrentMap&lt;String, String&gt; contextMap) {</span>
<span class="nc" id="L118">    this.setToken(token);</span>
<span class="nc" id="L119">    this.httpClientBuilder = httpClientBuilder;</span>
<span class="nc" id="L120">    this.wsFactory = wsFactory;</span>
<span class="nc" id="L121">    this.autoReconnect = autoReconnect;</span>
<span class="nc" id="L122">    this.audioEnabled = audioEnabled;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    this.shutdownHook = useShutdownHook ? new Thread(this::shutdown, &quot;JDA Shutdown Hook&quot;) : null;</span>
<span class="nc" id="L124">    this.bulkDeleteSplittingEnabled = bulkDeleteSplittingEnabled;</span>
<span class="nc" id="L125">    this.pool = new ScheduledThreadPoolExecutor(corePoolSize, new JDAThreadFactory());</span>
<span class="nc" id="L126">    this.maxReconnectDelay = maxReconnectDelay;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    this.sessionController = controller == null ? new SessionControllerAdapter() : controller;</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">    if (enableMDC) this.contextMap = contextMap == null ? new ConcurrentHashMap&lt;&gt;() : contextMap;</span>
<span class="nc" id="L129">    else this.contextMap = null;</span>

<span class="nc" id="L131">    this.presence = new PresenceImpl(this);</span>
<span class="nc" id="L132">    this.requester = new Requester(this);</span>
<span class="nc" id="L133">    this.requester.setRetryOnTimeout(retryOnTimeout);</span>

<span class="nc" id="L135">    this.jdaBot = new JDABotImpl(this);</span>
<span class="nc" id="L136">  }</span>

  public SessionController getSessionController() {
<span class="nc" id="L139">    return sessionController;</span>
  }

  public int login(String gatewayUrl, ShardInfo shardInfo) throws LoginException {
<span class="nc" id="L143">    this.gatewayUrl = gatewayUrl;</span>
<span class="nc" id="L144">    this.shardInfo = shardInfo;</span>

<span class="nc" id="L146">    setStatus(Status.LOGGING_IN);</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">    if (token == null || token.isEmpty())</span>
<span class="nc" id="L148">      throw new LoginException(&quot;Provided token was null or empty!&quot;);</span>

<span class="nc bnc" id="L150" title="All 4 branches missed.">    if (contextMap != null &amp;&amp; shardInfo != null) {</span>
<span class="nc" id="L151">      contextMap.put(&quot;jda.shard&quot;, shardInfo.getShardString());</span>
<span class="nc" id="L152">      contextMap.put(&quot;jda.shard.id&quot;, String.valueOf(shardInfo.getShardId()));</span>
<span class="nc" id="L153">      contextMap.put(&quot;jda.shard.total&quot;, String.valueOf(shardInfo.getShardTotal()));</span>
    }
<span class="nc" id="L155">    verifyToken();</span>
<span class="nc" id="L156">    LOG.info(&quot;Login Successful!&quot;);</span>

<span class="nc" id="L158">    client = new WebSocketClient(this);</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">    if (shutdownHook != null) Runtime.getRuntime().addShutdownHook(shutdownHook);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">    return shardInfo == null ? -1 : shardInfo.getShardTotal();</span>
  }

  public String getGateway() {
<span class="nc" id="L166">    return getSessionController().getGateway(this);</span>
  }

  // This method also checks for a valid bot token as it is required to get the recommended shard
  // count.
  public Pair&lt;String, Integer&gt; getGatewayBot() {
<span class="nc" id="L172">    return getSessionController().getGatewayBot(this);</span>
  }

  public ConcurrentMap&lt;String, String&gt; getContextMap() {
<span class="nc" id="L176">    return contextMap;</span>
  }

  public void setStatus(Status status) {
    //noinspection SynchronizeOnNonFinalField
<span class="nc" id="L181">    synchronized (this.status) {</span>
<span class="nc" id="L182">      Status oldStatus = this.status;</span>
<span class="nc" id="L183">      this.status = status;</span>

<span class="nc" id="L185">      eventManager.handle(new StatusChangeEvent(this, status, oldStatus));</span>
<span class="nc" id="L186">    }</span>
<span class="nc" id="L187">  }</span>

  public void setToken(String token) {
<span class="nc" id="L190">    this.token = &quot;Bot &quot; + token;</span>
<span class="nc" id="L191">  }</span>

  public void verifyToken() throws LoginException {
<span class="nc" id="L194">    this.verifyToken(false);</span>
<span class="nc" id="L195">  }</span>

  // @param alreadyFailed If has already been a failed attempt with the current configuration
  public void verifyToken(boolean alreadyFailed) throws LoginException {

<span class="nc" id="L200">    RestAction&lt;JSONObject&gt; login =</span>
<span class="nc" id="L201">        new RestAction&lt;JSONObject&gt;(this, Route.Self.GET_SELF.compile()) {</span>
          @Override
          protected void handleResponse(Response response, Request&lt;JSONObject&gt; request) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (response.isOk()) request.onSuccess(response.getObject());</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            else if (response.isRateLimit())</span>
<span class="nc" id="L206">              request.onFailure(new RateLimitedException(request.getRoute(), response.retryAfter));</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            else if (response.code == 401) request.onSuccess(null);</span>
            else
<span class="nc" id="L209">              request.onFailure(</span>
                  new LoginException(
                      &quot;When verifying the authenticity of the provided token, Discord returned an unknown response:\n&quot;
<span class="nc" id="L212">                          + response.toString()));</span>
<span class="nc" id="L213">          }</span>
        };

    JSONObject userResponse;

<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (!alreadyFailed) {</span>
<span class="nc" id="L219">      userResponse = checkToken(login);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      if (userResponse != null) {</span>
<span class="nc" id="L221">        verifyAccountType(userResponse);</span>
<span class="nc" id="L222">        return;</span>
      }
    }

    // If we received a null return for userResponse, then that means we hit a 401.
    // 401 occurs when we attempt to access the users/@me endpoint with the wrong token prefix.
    // e.g: If we use a Client token and prefix it with &quot;Bot &quot;, or use a bot token and don't prefix
    // it.
    // It also occurs when we attempt to access the endpoint with an invalid token.
    // The code below already knows that something is wrong with the token. We want to determine if
    // it is invalid
    // or if the developer attempted to login with a token using the wrong AccountType.

    // If we attempted to login as a Bot, remove the &quot;Bot &quot; prefix and set the Requester to be a
    // client.
<span class="nc" id="L237">    token = token.substring(&quot;Bot &quot;.length());</span>
<span class="nc" id="L238">    requester = new Requester(this);</span>

<span class="nc" id="L240">    userResponse = checkToken(login);</span>

    // If the response isn't null (thus it didn't 401) send it to the secondary verify method to
    // determine
    // which account type the developer wrongly attempted to login as
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (userResponse != null) verifyAccountType(userResponse);</span>
    else // We 401'd again. This is an invalid token
<span class="nc" id="L247">    throw new LoginException(&quot;The provided token is invalid!&quot;);</span>
<span class="nc" id="L248">  }</span>

  private void verifyAccountType(JSONObject userResponse) {
<span class="nc bnc" id="L251" title="All 4 branches missed.">    if (!userResponse.has(&quot;bot&quot;) || !userResponse.getBoolean(&quot;bot&quot;)) {</span>
<span class="nc" id="L252">      throw new AccountTypeException(&quot;Attempted to login as a BOT with a CLIENT token!&quot;);</span>
    }
<span class="nc" id="L254">  }</span>

  private JSONObject checkToken(RestAction&lt;JSONObject&gt; login) throws LoginException {
    JSONObject userResponse;
    try {
<span class="nc" id="L259">      userResponse = login.complete();</span>
<span class="nc" id="L260">    } catch (RuntimeException e) {</span>
      // We check if the LoginException is masked inside of a ExecutionException which is masked
      // inside of the RuntimeException
<span class="nc bnc" id="L263" title="All 2 branches missed.">      Throwable ex = e.getCause() instanceof ExecutionException ? e.getCause().getCause() : null;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      if (ex instanceof LoginException) throw new LoginException(ex.getMessage());</span>
<span class="nc" id="L265">      else throw e;</span>
<span class="nc" id="L266">    }</span>
<span class="nc" id="L267">    return userResponse;</span>
  }

  @Override
  public String getToken() {
<span class="nc" id="L272">    return token;</span>
  }

  @Override
  public boolean isAudioEnabled() {
<span class="nc" id="L277">    return audioEnabled;</span>
  }

  @Override
  public boolean isBulkDeleteSplittingEnabled() {
<span class="nc" id="L282">    return bulkDeleteSplittingEnabled;</span>
  }

  @Override
  public void setAutoReconnect(boolean autoReconnect) {
<span class="nc" id="L287">    this.autoReconnect = autoReconnect;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">    if (client != null) client.setAutoReconnect(autoReconnect);</span>
<span class="nc" id="L289">  }</span>

  @Override
  public void setRequestTimeoutRetry(boolean retryOnTimeout) {
<span class="nc" id="L293">    requester.setRetryOnTimeout(retryOnTimeout);</span>
<span class="nc" id="L294">  }</span>

  @Override
  public boolean isAutoReconnect() {
<span class="nc" id="L298">    return autoReconnect;</span>
  }

  @Override
  public Status getStatus() {
<span class="nc" id="L303">    return status;</span>
  }

  @Override
  public long getPing() {
<span class="nc" id="L308">    return ping;</span>
  }

  @Override
  public List&lt;String&gt; getCloudflareRays() {
<span class="nc" id="L313">    return Collections.unmodifiableList(new LinkedList&lt;&gt;(client.getCfRays()));</span>
  }

  @Override
  public List&lt;String&gt; getWebSocketTrace() {
<span class="nc" id="L318">    return Collections.unmodifiableList(new LinkedList&lt;&gt;(client.getTraces()));</span>
  }

  @Override
  public List&lt;Guild&gt; getMutualGuilds(User... users) {
<span class="nc" id="L323">    Checks.notNull(users, &quot;users&quot;);</span>
<span class="nc" id="L324">    return getMutualGuilds(Arrays.asList(users));</span>
  }

  @Override
  public List&lt;Guild&gt; getMutualGuilds(Collection&lt;User&gt; users) {
<span class="nc" id="L329">    Checks.notNull(users, &quot;users&quot;);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (User u : users) Checks.notNull(u, &quot;All users&quot;);</span>
<span class="nc" id="L331">    return Collections.unmodifiableList(</span>
<span class="nc" id="L332">        getGuilds()</span>
<span class="nc" id="L333">            .stream()</span>
<span class="nc" id="L334">            .filter(guild -&gt; users.stream().allMatch(guild::isMember))</span>
<span class="nc" id="L335">            .collect(Collectors.toList()));</span>
  }

  @Override
  public RestAction&lt;User&gt; retrieveUserById(String id) {
<span class="nc" id="L340">    return retrieveUserById(MiscUtil.parseSnowflake(id));</span>
  }

  @Override
  public RestAction&lt;User&gt; retrieveUserById(long id) {
    // check cache
<span class="nc" id="L346">    User user = this.getUserById(id);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">    if (user != null) return new RestAction.EmptyRestAction&lt;&gt;(this, user);</span>

<span class="nc" id="L349">    Route.CompiledRoute route = Route.Users.GET_USER.compile(Long.toUnsignedString(id));</span>
<span class="nc" id="L350">    return new RestAction&lt;User&gt;(this, route) {</span>
      @Override
      protected void handleResponse(Response response, Request&lt;User&gt; request) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (!response.isOk()) {</span>
<span class="nc" id="L354">          request.onFailure(response);</span>
<span class="nc" id="L355">          return;</span>
        }
<span class="nc" id="L357">        JSONObject user = response.getObject();</span>
<span class="nc" id="L358">        request.onSuccess(getEntityBuilder().createFakeUser(user, false));</span>
<span class="nc" id="L359">      }</span>
    };
  }

  @Override
  public CacheView&lt;AudioManager&gt; getAudioManagerCache() {
<span class="nc" id="L365">    return audioManagers;</span>
  }

  @Override
  public SnowflakeCacheView&lt;Guild&gt; getGuildCache() {
<span class="nc" id="L370">    return guildCache;</span>
  }

  @Override
  public SnowflakeCacheView&lt;Role&gt; getRoleCache() {
<span class="nc" id="L375">    return CacheView.allSnowflakes(() -&gt; guildCache.stream().map(Guild::getRoleCache));</span>
  }

  @Override
  public SnowflakeCacheView&lt;Emote&gt; getEmoteCache() {
<span class="nc" id="L380">    return CacheView.allSnowflakes(() -&gt; guildCache.stream().map(Guild::getEmoteCache));</span>
  }

  @Override
  public SnowflakeCacheView&lt;Category&gt; getCategoryCache() {
<span class="nc" id="L385">    return categories;</span>
  }

  @Override
  public SnowflakeCacheView&lt;TextChannel&gt; getTextChannelCache() {
<span class="nc" id="L390">    return textChannelCache;</span>
  }

  @Override
  public SnowflakeCacheView&lt;VoiceChannel&gt; getVoiceChannelCache() {
<span class="nc" id="L395">    return voiceChannelCache;</span>
  }

  @Override
  public SnowflakeCacheView&lt;PrivateChannel&gt; getPrivateChannelCache() {
<span class="nc" id="L400">    return privateChannelCache;</span>
  }

  @Override
  public SnowflakeCacheView&lt;User&gt; getUserCache() {
<span class="nc" id="L405">    return userCache;</span>
  }

  public SelfUser getSelfUser() {
<span class="nc" id="L409">    return selfUser;</span>
  }

  @Override
  public void shutdownNow() {
<span class="nc" id="L414">    shutdown();</span>

<span class="nc" id="L416">    pool.shutdownNow();</span>
<span class="nc" id="L417">    getRequester().shutdownNow();</span>
<span class="nc" id="L418">  }</span>

  @Override
  public void shutdown() {
<span class="nc bnc" id="L422" title="All 4 branches missed.">    if (status == Status.SHUTDOWN || status == Status.SHUTTING_DOWN) return;</span>

<span class="nc" id="L424">    setStatus(Status.SHUTTING_DOWN);</span>
<span class="nc" id="L425">    audioManagers.forEach(AudioManager::closeAudioConnection);</span>
<span class="nc" id="L426">    audioManagers.clear();</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">    if (audioKeepAlivePool != null) audioKeepAlivePool.shutdownNow();</span>

<span class="nc" id="L430">    getClient().shutdown();</span>

<span class="nc" id="L432">    final long time = 5L;</span>
<span class="nc" id="L433">    final TimeUnit unit = TimeUnit.SECONDS;</span>
<span class="nc" id="L434">    getRequester().shutdown(time, unit);</span>
<span class="nc" id="L435">    pool.setKeepAliveTime(time, unit);</span>
<span class="nc" id="L436">    pool.allowCoreThreadTimeOut(true);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">    if (shutdownHook != null) {</span>
      try {
<span class="nc" id="L440">        Runtime.getRuntime().removeShutdownHook(shutdownHook);</span>
<span class="nc" id="L441">      } catch (Exception ignored) {</span>
<span class="nc" id="L442">      }</span>
    }

<span class="nc" id="L445">    setStatus(Status.SHUTDOWN);</span>
<span class="nc" id="L446">  }</span>

  @Override
  public JDABotImpl asBot() {
<span class="nc" id="L450">    return jdaBot;</span>
  }

  @Override
  public long getResponseTotal() {
<span class="nc" id="L455">    return responseTotal;</span>
  }

  @Override
  public int getMaxReconnectDelay() {
<span class="nc" id="L460">    return maxReconnectDelay;</span>
  }

  @Override
  public ShardInfo getShardInfo() {
<span class="nc" id="L465">    return shardInfo;</span>
  }

  @Override
  public Presence getPresence() {
<span class="nc" id="L470">    return presence;</span>
  }

  @Override
  public void setEventManager(IEventManager eventManager) {
<span class="nc" id="L475">    this.eventManager = eventManager;</span>
<span class="nc" id="L476">  }</span>

  @Override
  public void addEventListener(Object... listeners) {
<span class="nc" id="L480">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">    for (Object listener : listeners) eventManager.register(listener);</span>
<span class="nc" id="L483">  }</span>

  @Override
  public void removeEventListener(Object... listeners) {
<span class="nc" id="L487">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>

<span class="nc bnc" id="L489" title="All 2 branches missed.">    for (Object listener : listeners) eventManager.unregister(listener);</span>
<span class="nc" id="L490">  }</span>

  @Override
  public List&lt;Object&gt; getRegisteredListeners() {
<span class="nc" id="L494">    return Collections.unmodifiableList(eventManager.getRegisteredListeners());</span>
  }

  @Override
  public GuildAction createGuild(String name) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">    if (guildCache.size() &gt;= 10) {</span>
<span class="nc" id="L500">      throw new IllegalStateException(&quot;Cannot create a Guild with a Bot in more than 10 guilds!&quot;);</span>
    }

<span class="nc" id="L503">    return new GuildAction(this, name);</span>
  }

  public EntityBuilder getEntityBuilder() {
<span class="nc" id="L507">    return entityBuilder;</span>
  }

  public GuildLock getGuildLock() {
<span class="nc" id="L511">    return this.guildLock;</span>
  }

  public void setPing(long ping) {
<span class="nc" id="L515">    this.ping = ping;</span>
<span class="nc" id="L516">  }</span>

  public Requester getRequester() {
<span class="nc" id="L519">    return requester;</span>
  }

  public IEventManager getEventManager() {
<span class="nc" id="L523">    return eventManager;</span>
  }

  public WebSocketFactory getWebSocketFactory() {
<span class="nc" id="L527">    return wsFactory;</span>
  }

  public WebSocketClient getClient() {
<span class="nc" id="L531">    return client;</span>
  }

  public TLongObjectMap&lt;User&gt; getUserMap() {
<span class="nc" id="L535">    return userCache.getMap();</span>
  }

  public TLongObjectMap&lt;Guild&gt; getGuildMap() {
<span class="nc" id="L539">    return guildCache.getMap();</span>
  }

  public TLongObjectMap&lt;Category&gt; getCategoryMap() {
<span class="nc" id="L543">    return categories.getMap();</span>
  }

  public TLongObjectMap&lt;TextChannel&gt; getTextChannelMap() {
<span class="nc" id="L547">    return textChannelCache.getMap();</span>
  }

  public TLongObjectMap&lt;VoiceChannel&gt; getVoiceChannelMap() {
<span class="nc" id="L551">    return voiceChannelCache.getMap();</span>
  }

  public TLongObjectMap&lt;PrivateChannel&gt; getPrivateChannelMap() {
<span class="nc" id="L555">    return privateChannelCache.getMap();</span>
  }

  public TLongObjectMap&lt;User&gt; getFakeUserMap() {
<span class="nc" id="L559">    return fakeUsers;</span>
  }

  public TLongObjectMap&lt;PrivateChannel&gt; getFakePrivateChannelMap() {
<span class="nc" id="L563">    return fakePrivateChannels;</span>
  }

  public TLongObjectMap&lt;AudioManager&gt; getAudioManagerMap() {
<span class="nc" id="L567">    return audioManagers.getMap();</span>
  }

  public void setSelfUser(SelfUser selfUser) {
<span class="nc" id="L571">    this.selfUser = selfUser;</span>
<span class="nc" id="L572">  }</span>

  public void setResponseTotal(int responseTotal) {
<span class="nc" id="L575">    this.responseTotal = responseTotal;</span>
<span class="nc" id="L576">  }</span>

  public String getIdentifierString() {
<span class="nc bnc" id="L579" title="All 2 branches missed.">    if (shardInfo != null) return &quot;JDA &quot; + shardInfo.getShardString();</span>
<span class="nc" id="L580">    else return &quot;JDA&quot;;</span>
  }

  public EventCache getEventCache() {
<span class="nc" id="L584">    return eventCache;</span>
  }

  public OkHttpClient.Builder getHttpClientBuilder() {
<span class="nc" id="L588">    return httpClientBuilder;</span>
  }

<span class="nc" id="L591">  private class JDAThreadFactory implements ThreadFactory {</span>
    @Override
    public Thread newThread(Runnable r) {
<span class="nc" id="L594">      final Thread thread = new Thread(r, &quot;JDA-Thread &quot; + getIdentifierString());</span>
<span class="nc" id="L595">      thread.setDaemon(true);</span>
<span class="nc" id="L596">      return thread;</span>
    }
  }

  public ScheduledThreadPoolExecutor getAudioKeepAlivePool() {
<span class="nc" id="L601">    ScheduledThreadPoolExecutor akap = audioKeepAlivePool;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">    if (akap == null) {</span>
<span class="nc" id="L603">      synchronized (akapLock) {</span>
<span class="nc" id="L604">        akap = audioKeepAlivePool;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (akap == null)</span>
<span class="nc" id="L606">          akap =</span>
              audioKeepAlivePool =
                  new ScheduledThreadPoolExecutor(
                      1, new AudioWebSocket.KeepAliveThreadFactory(this));
<span class="nc" id="L610">      }</span>
    }
<span class="nc" id="L612">    return akap;</span>
  }

  public String getGatewayUrl() {
<span class="nc" id="L616">    return gatewayUrl;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>