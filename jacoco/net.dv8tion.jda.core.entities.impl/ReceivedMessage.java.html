<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReceivedMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.entities.impl</a> &gt; <span class="el_source">ReceivedMessage.java</span></div><h1>ReceivedMessage.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.entities.impl;

import gnu.trove.set.TLongSet;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.dv8tion.jda.client.entities.Group;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.MessageBuilder;
import net.dv8tion.jda.core.Permission;
import net.dv8tion.jda.core.entities.*;
import net.dv8tion.jda.core.exceptions.InsufficientPermissionException;
import net.dv8tion.jda.core.requests.RestAction;
import net.dv8tion.jda.core.requests.restaction.AuditableRestAction;
import net.dv8tion.jda.core.requests.restaction.MessageAction;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.MiscUtil;
import org.apache.commons.collections4.CollectionUtils;

public class ReceivedMessage extends AbstractMessage {
<span class="nc" id="L38">  private final Object mutex = new Object();</span>

  protected final JDAImpl api;
  protected final long id;
  protected final MessageType type;
  protected final MessageChannel channel;
  protected final boolean fromWebhook;
  protected final boolean mentionsEveryone;
  protected final boolean pinned;
  protected final User author;
  protected final OffsetDateTime editedTime;
  protected final List&lt;MessageReaction&gt; reactions;
  protected final List&lt;Attachment&gt; attachments;
  protected final List&lt;MessageEmbed&gt; embeds;
  protected final TLongSet mentionedUsers;
  protected final TLongSet mentionedRoles;

  // LAZY EVALUATED
<span class="nc" id="L56">  protected String altContent = null;</span>
<span class="nc" id="L57">  protected String strippedContent = null;</span>

<span class="nc" id="L59">  protected List&lt;User&gt; userMentions = null;</span>
<span class="nc" id="L60">  protected List&lt;Emote&gt; emoteMentions = null;</span>
<span class="nc" id="L61">  protected List&lt;Role&gt; roleMentions = null;</span>
<span class="nc" id="L62">  protected List&lt;TextChannel&gt; channelMentions = null;</span>
<span class="nc" id="L63">  protected List&lt;String&gt; invites = null;</span>

  public ReceivedMessage(
      long id,
      MessageChannel channel,
      MessageType type,
      boolean fromWebhook,
      boolean mentionsEveryone,
      TLongSet mentionedUsers,
      TLongSet mentionedRoles,
      boolean tts,
      boolean pinned,
      String content,
      String nonce,
      User author,
      OffsetDateTime editTime,
      List&lt;MessageReaction&gt; reactions,
      List&lt;Attachment&gt; attachments,
      List&lt;MessageEmbed&gt; embeds) {
<span class="nc" id="L82">    super(content, nonce, tts);</span>
<span class="nc" id="L83">    this.id = id;</span>
<span class="nc" id="L84">    this.channel = channel;</span>
<span class="nc" id="L85">    this.type = type;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    this.api = (channel != null) ? (JDAImpl) channel.getJDA() : null;</span>
<span class="nc" id="L87">    this.fromWebhook = fromWebhook;</span>
<span class="nc" id="L88">    this.mentionsEveryone = mentionsEveryone;</span>
<span class="nc" id="L89">    this.pinned = pinned;</span>
<span class="nc" id="L90">    this.author = author;</span>
<span class="nc" id="L91">    this.editedTime = editTime;</span>
<span class="nc" id="L92">    this.reactions = Collections.unmodifiableList(reactions);</span>
<span class="nc" id="L93">    this.attachments = Collections.unmodifiableList(attachments);</span>
<span class="nc" id="L94">    this.embeds = Collections.unmodifiableList(embeds);</span>
<span class="nc" id="L95">    this.mentionedUsers = mentionedUsers;</span>
<span class="nc" id="L96">    this.mentionedRoles = mentionedRoles;</span>
<span class="nc" id="L97">  }</span>

  @Override
  public JDA getJDA() {
<span class="nc" id="L101">    return api;</span>
  }

  @Override
  public boolean isPinned() {
<span class="nc" id="L106">    return pinned;</span>
  }

  @Override
  public RestAction&lt;Void&gt; pin() {
<span class="nc" id="L111">    return channel.pinMessageById(getIdLong());</span>
  }

  @Override
  public RestAction&lt;Void&gt; unpin() {
<span class="nc" id="L116">    return channel.unpinMessageById(getIdLong());</span>
  }

  @Override
  public RestAction&lt;Void&gt; addReaction(Emote emote) {
<span class="nc" id="L121">    Checks.notNull(emote, &quot;Emote&quot;);</span>

<span class="nc" id="L123">    MessageReaction reaction =</span>
        reactions
<span class="nc" id="L125">            .parallelStream()</span>
<span class="nc" id="L126">            .filter(r -&gt; Objects.equals(r.getReactionEmote().getId(), emote.getId()))</span>
<span class="nc" id="L127">            .findFirst()</span>
<span class="nc" id="L128">            .orElse(null);</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">    if (reaction == null) {</span>
<span class="nc" id="L131">      checkFake(emote, &quot;Emote&quot;);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">      if (!emote.canInteract(getJDA().getSelfUser(), channel))</span>
<span class="nc" id="L133">        throw new IllegalArgumentException(</span>
            &quot;Cannot react with the provided emote because it is not available in the current channel.&quot;);
<span class="nc bnc" id="L135" title="All 2 branches missed.">    } else if (reaction.isSelf()) {</span>
<span class="nc" id="L136">      return new RestAction.EmptyRestAction&lt;&gt;(getJDA(), null);</span>
    }

<span class="nc" id="L139">    return channel.addReactionById(getIdLong(), emote);</span>
  }

  @Override
  public RestAction&lt;Void&gt; addReaction(String unicode) {
<span class="nc" id="L144">    Checks.notEmpty(unicode, &quot;Provided Unicode&quot;);</span>

<span class="nc" id="L146">    MessageReaction reaction =</span>
        reactions
<span class="nc" id="L148">            .parallelStream()</span>
<span class="nc" id="L149">            .filter(r -&gt; Objects.equals(r.getReactionEmote().getName(), unicode))</span>
<span class="nc" id="L150">            .findFirst()</span>
<span class="nc" id="L151">            .orElse(null);</span>

<span class="nc bnc" id="L153" title="All 4 branches missed.">    if (reaction != null &amp;&amp; reaction.isSelf())</span>
<span class="nc" id="L154">      return new RestAction.EmptyRestAction&lt;&gt;(getJDA(), null);</span>

<span class="nc" id="L156">    return channel.addReactionById(getIdLong(), unicode);</span>
  }

  @Override
  public RestAction&lt;Void&gt; clearReactions() {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (!isFromType(ChannelType.TEXT))</span>
<span class="nc" id="L162">      throw new IllegalStateException(</span>
          &quot;Cannot clear reactions from a message in a Group or PrivateChannel.&quot;);
<span class="nc" id="L164">    return getTextChannel().clearReactionsById(getId());</span>
  }

  @Override
  public MessageType getType() {
<span class="nc" id="L169">    return type;</span>
  }

  @Override
  public long getIdLong() {
<span class="nc" id="L174">    return id;</span>
  }

  @Override
  public synchronized List&lt;User&gt; getMentionedUsers() {
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (userMentions == null) {</span>
<span class="nc" id="L180">      userMentions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L181">      Matcher matcher = MentionType.USER.getPattern().matcher(content);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">      while (matcher.find()) {</span>
        try {
<span class="nc" id="L184">          long id = MiscUtil.parseSnowflake(matcher.group(1));</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">          if (!mentionedUsers.contains(id)) continue;</span>
<span class="nc" id="L186">          User user = getJDA().getUserById(id);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">          if (user == null) user = api.getFakeUserMap().get(id);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">          if (user != null) userMentions.add(user);</span>
<span class="nc" id="L189">        } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L190">        }</span>
      }
<span class="nc" id="L192">      userMentions = Collections.unmodifiableList(userMentions);</span>
    }

<span class="nc" id="L195">    return userMentions;</span>
  }

  @Override
  public synchronized List&lt;TextChannel&gt; getMentionedChannels() {
<span class="nc bnc" id="L200" title="All 2 branches missed.">    if (channelMentions == null) {</span>
<span class="nc" id="L201">      channelMentions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L202">      Matcher matcher = MentionType.CHANNEL.getPattern().matcher(content);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">      while (matcher.find()) {</span>
        try {
<span class="nc" id="L205">          String id = matcher.group(1);</span>
<span class="nc" id="L206">          TextChannel channel = getJDA().getTextChannelById(id);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">          if (channel != null) channelMentions.add(channel);</span>
<span class="nc" id="L208">        } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L209">        }</span>
      }
<span class="nc" id="L211">      channelMentions = Collections.unmodifiableList(channelMentions);</span>
    }

<span class="nc" id="L214">    return channelMentions;</span>
  }

  @Override
  public synchronized List&lt;Role&gt; getMentionedRoles() {
<span class="nc bnc" id="L219" title="All 2 branches missed.">    if (roleMentions == null) {</span>
<span class="nc" id="L220">      roleMentions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L221">      Matcher matcher = MentionType.ROLE.getPattern().matcher(content);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      while (matcher.find()) {</span>
        try {
<span class="nc" id="L224">          long id = MiscUtil.parseSnowflake(matcher.group(1));</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">          if (!mentionedRoles.contains(id)) continue;</span>
<span class="nc" id="L226">          Role role = null;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">          if (isFromType(</span>
              ChannelType.TEXT)) // role lookup is faster if its in the same guild (no global map)
<span class="nc" id="L229">          role = getGuild().getRoleById(id);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">          if (role == null) role = getJDA().getRoleById(id);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">          if (role != null) roleMentions.add(role);</span>
<span class="nc" id="L232">        } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L233">        }</span>
      }
<span class="nc" id="L235">      roleMentions = Collections.unmodifiableList(roleMentions);</span>
    }

<span class="nc" id="L238">    return roleMentions;</span>
  }

  @Override
  public List&lt;Member&gt; getMentionedMembers(Guild guild) {
<span class="nc" id="L243">    Checks.notNull(guild, &quot;Guild&quot;);</span>
<span class="nc" id="L244">    List&lt;User&gt; mentionedUsers = getMentionedUsers();</span>
<span class="nc" id="L245">    List&lt;Member&gt; members = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    for (User user : mentionedUsers) {</span>
<span class="nc" id="L247">      Member member = guild.getMember(user);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (member != null) members.add(member);</span>
<span class="nc" id="L249">    }</span>

<span class="nc" id="L251">    return Collections.unmodifiableList(members);</span>
  }

  @Override
  public List&lt;Member&gt; getMentionedMembers() {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (isFromType(ChannelType.TEXT)) return getMentionedMembers(getGuild());</span>
    else
<span class="nc" id="L258">      throw new IllegalStateException(</span>
          &quot;You must specify a Guild for Messages which are not sent from a TextChannel!&quot;);
  }

  @Override
  public List&lt;IMentionable&gt; getMentions(MentionType... types) {
<span class="nc bnc" id="L264" title="All 4 branches missed.">    if (types == null || types.length == 0) return getMentions(MentionType.values());</span>
<span class="nc" id="L265">    List&lt;IMentionable&gt; mentions = new ArrayList&lt;&gt;();</span>
    // boolean duplicate checks
    // not using Set because channel and role might have the same ID
<span class="nc" id="L268">    boolean channel = false;</span>
<span class="nc" id="L269">    boolean role = false;</span>
<span class="nc" id="L270">    boolean user = false;</span>
<span class="nc" id="L271">    boolean emote = false;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">    for (MentionType type : types) {</span>
<span class="nc bnc" id="L273" title="All 5 branches missed.">      switch (type) {</span>
        case EVERYONE:
        case HERE:
        default:
<span class="nc" id="L277">          continue;</span>
        case CHANNEL:
<span class="nc bnc" id="L279" title="All 2 branches missed.">          if (!channel) mentions.addAll(getMentionedChannels());</span>
<span class="nc" id="L280">          channel = true;</span>
<span class="nc" id="L281">          break;</span>
        case USER:
<span class="nc bnc" id="L283" title="All 2 branches missed.">          if (!user) mentions.addAll(getMentionedUsers());</span>
<span class="nc" id="L284">          user = true;</span>
<span class="nc" id="L285">          break;</span>
        case ROLE:
<span class="nc bnc" id="L287" title="All 2 branches missed.">          if (!role) mentions.addAll(getMentionedRoles());</span>
<span class="nc" id="L288">          role = true;</span>
<span class="nc" id="L289">          break;</span>
        case EMOTE:
<span class="nc bnc" id="L291" title="All 2 branches missed.">          if (!emote) mentions.addAll(getEmotes());</span>
<span class="nc" id="L292">          emote = true;</span>
      }
    }
<span class="nc" id="L295">    return Collections.unmodifiableList(mentions);</span>
  }

  @Override
  public boolean isMentioned(IMentionable mentionable, MentionType... types) {
<span class="nc" id="L300">    Checks.notNull(types, &quot;Mention Types&quot;);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    if (types.length == 0) return isMentioned(mentionable, MentionType.values());</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">    final boolean isUserEntity = mentionable instanceof User || mentionable instanceof Member;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    for (MentionType type : types) {</span>
<span class="nc bnc" id="L304" title="All 7 branches missed.">      switch (type) {</span>
        case HERE:
          {
<span class="nc bnc" id="L307" title="All 4 branches missed.">            if (isMass(&quot;@here&quot;) &amp;&amp; isUserEntity) return true;</span>
            break;
          }
        case EVERYONE:
          {
<span class="nc bnc" id="L312" title="All 4 branches missed.">            if (isMass(&quot;@everyone&quot;) &amp;&amp; isUserEntity) return true;</span>
            break;
          }
        case USER:
          {
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (isUserMentioned(mentionable)) return true;</span>
            break;
          }
        case ROLE:
          {
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (isRoleMentioned(mentionable)) return true;</span>
            break;
          }
        case CHANNEL:
          {
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (mentionable instanceof TextChannel) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">              if (getMentionedChannels().contains(mentionable)) return true;</span>
            }
            break;
          }
        case EMOTE:
          {
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (mentionable instanceof Emote) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">              if (getEmotes().contains(mentionable)) return true;</span>
            }
            break;
          }
          //              default: continue;
      }
    }
<span class="nc" id="L342">    return false;</span>
  }

  private boolean isUserMentioned(IMentionable mentionable) {
<span class="nc bnc" id="L346" title="All 2 branches missed.">    if (mentionable instanceof User) {</span>
<span class="nc" id="L347">      return getMentionedUsers().contains(mentionable);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">    } else if (mentionable instanceof Member) {</span>
<span class="nc" id="L349">      final Member member = (Member) mentionable;</span>
<span class="nc" id="L350">      return getMentionedUsers().contains(member.getUser());</span>
    }
<span class="nc" id="L352">    return false;</span>
  }

  private boolean isRoleMentioned(IMentionable mentionable) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">    if (mentionable instanceof Role) {</span>
<span class="nc" id="L357">      return getMentionedRoles().contains(mentionable);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">    } else if (mentionable instanceof Member) {</span>
<span class="nc" id="L359">      final Member member = (Member) mentionable;</span>
<span class="nc" id="L360">      return CollectionUtils.containsAny(getMentionedRoles(), member.getRoles());</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">    } else if (isFromType(ChannelType.TEXT) &amp;&amp; mentionable instanceof User) {</span>
<span class="nc" id="L362">      final Member member = getGuild().getMember((User) mentionable);</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">      return member != null &amp;&amp; CollectionUtils.containsAny(getMentionedRoles(), member.getRoles());</span>
    }
<span class="nc" id="L365">    return false;</span>
  }

  private boolean isMass(String s) {
<span class="nc bnc" id="L369" title="All 4 branches missed.">    return mentionsEveryone &amp;&amp; content.contains(s);</span>
  }

  @Override
  public boolean mentionsEveryone() {
<span class="nc" id="L374">    return mentionsEveryone;</span>
  }

  @Override
  public boolean isEdited() {
<span class="nc bnc" id="L379" title="All 2 branches missed.">    return editedTime != null;</span>
  }

  @Override
  public OffsetDateTime getEditedTime() {
<span class="nc" id="L384">    return editedTime;</span>
  }

  @Override
  public User getAuthor() {
<span class="nc" id="L389">    return author;</span>
  }

  @Override
  public Member getMember() {
<span class="nc bnc" id="L394" title="All 2 branches missed.">    return isFromType(ChannelType.TEXT) ? getGuild().getMember(getAuthor()) : null;</span>
  }

  @Override
  public String getContentStripped() {
<span class="nc bnc" id="L399" title="All 2 branches missed.">    if (strippedContent != null) return strippedContent;</span>
<span class="nc" id="L400">    synchronized (mutex) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">      if (strippedContent != null) return strippedContent;</span>
<span class="nc" id="L402">      String tmp = getContentDisplay();</span>
      // all the formatting keys to keep track of
<span class="nc" id="L404">      String[] keys = new String[] {&quot;*&quot;, &quot;_&quot;, &quot;`&quot;, &quot;~~&quot;};</span>

      // find all tokens (formatting strings described above)
<span class="nc" id="L407">      TreeSet&lt;FormatToken&gt; tokens = new TreeSet&lt;&gt;(Comparator.comparingInt(t -&gt; t.start));</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">      for (String key : keys) {</span>
<span class="nc" id="L409">        Matcher matcher = Pattern.compile(Pattern.quote(key)).matcher(tmp);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        while (matcher.find()) tokens.add(new FormatToken(key, matcher.start()));</span>
      }

      // iterate over all tokens, find all matching pairs, and add them to the list toRemove
<span class="nc" id="L414">      Deque&lt;FormatToken&gt; stack = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L415">      List&lt;FormatToken&gt; toRemove = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L416">      boolean inBlock = false;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">      for (FormatToken token : tokens) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (stack.isEmpty()</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            || !stack.peek().format.equals(token.format)</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            || stack.peek().start + token.format.length() == token.start) {</span>

          // we are at opening tag
<span class="nc bnc" id="L423" title="All 2 branches missed.">          if (!inBlock) {</span>
            // we are outside of block -&gt; handle normally
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (token.format.equals(&quot;`&quot;)) {</span>
              // block start... invalidate all previous tags
<span class="nc" id="L427">              stack.clear();</span>
<span class="nc" id="L428">              inBlock = true;</span>
            }
<span class="nc" id="L430">            stack.push(token);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">          } else if (token.format.equals(&quot;`&quot;)) {</span>
            // we are inside of a block -&gt; handle only block tag
<span class="nc" id="L433">            stack.push(token);</span>
          }
<span class="nc bnc" id="L435" title="All 2 branches missed.">        } else if (!stack.isEmpty()) {</span>
          // we found a matching close-tag
<span class="nc" id="L437">          toRemove.add(stack.pop());</span>
<span class="nc" id="L438">          toRemove.add(token);</span>
<span class="nc bnc" id="L439" title="All 4 branches missed.">          if (token.format.equals(&quot;`&quot;) &amp;&amp; stack.isEmpty())</span>
            // close tag closed the block
<span class="nc" id="L441">            inBlock = false;</span>
        }
<span class="nc" id="L443">      }</span>

      // sort tags to remove by their start-index and iteratively build the remaining string
<span class="nc" id="L446">      toRemove.sort(Comparator.comparingInt(t -&gt; t.start));</span>
<span class="nc" id="L447">      StringBuilder out = new StringBuilder();</span>
<span class="nc" id="L448">      int currIndex = 0;</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">      for (FormatToken formatToken : toRemove) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (currIndex &lt; formatToken.start) out.append(tmp.substring(currIndex, formatToken.start));</span>
<span class="nc" id="L451">        currIndex = formatToken.start + formatToken.format.length();</span>
<span class="nc" id="L452">      }</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">      if (currIndex &lt; tmp.length()) out.append(tmp.substring(currIndex));</span>
      // return the stripped text, escape all remaining formatting characters (did not have matching
      // open/close before or were left/right of block
<span class="nc" id="L456">      return strippedContent =</span>
<span class="nc" id="L457">          out.toString().replace(&quot;*&quot;, &quot;\\*&quot;).replace(&quot;_&quot;, &quot;\\_&quot;).replace(&quot;~&quot;, &quot;\\~&quot;);</span>
    }
  }

  @Override
  public String getContentDisplay() {
<span class="nc bnc" id="L463" title="All 2 branches missed.">    if (altContent != null) return altContent;</span>
<span class="nc" id="L464">    synchronized (mutex) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">      if (altContent != null) return altContent;</span>
<span class="nc" id="L466">      String tmp = content;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">      for (User user : getMentionedUsers()) {</span>
        String name;
<span class="nc bnc" id="L469" title="All 4 branches missed.">        if (isFromType(ChannelType.TEXT) &amp;&amp; getGuild().isMember(user))</span>
<span class="nc" id="L470">          name = getGuild().getMember(user).getEffectiveName();</span>
<span class="nc" id="L471">        else name = user.getName();</span>
<span class="nc" id="L472">        tmp =</span>
<span class="nc" id="L473">            tmp.replaceAll(</span>
<span class="nc" id="L474">                &quot;&lt;@!?&quot; + Pattern.quote(user.getId()) + '&gt;', '@' + Matcher.quoteReplacement(name));</span>
<span class="nc" id="L475">      }</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">      for (Emote emote : getEmotes()) {</span>
<span class="nc" id="L477">        tmp = tmp.replace(emote.getAsMention(), &quot;:&quot; + emote.getName() + &quot;:&quot;);</span>
<span class="nc" id="L478">      }</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      for (TextChannel mentionedChannel : getMentionedChannels()) {</span>
<span class="nc" id="L480">        tmp = tmp.replace(mentionedChannel.getAsMention(), '#' + mentionedChannel.getName());</span>
<span class="nc" id="L481">      }</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      for (Role mentionedRole : getMentionedRoles()) {</span>
<span class="nc" id="L483">        tmp = tmp.replace(mentionedRole.getAsMention(), '@' + mentionedRole.getName());</span>
<span class="nc" id="L484">      }</span>
<span class="nc" id="L485">      return altContent = tmp;</span>
    }
  }

  @Override
  public String getContentRaw() {
<span class="nc" id="L491">    return content;</span>
  }

  @Override
  public List&lt;String&gt; getInvites() {
<span class="nc bnc" id="L496" title="All 2 branches missed.">    if (invites != null) return invites;</span>
<span class="nc" id="L497">    synchronized (mutex) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">      if (invites != null) return invites;</span>
<span class="nc" id="L499">      invites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L500">      Matcher m = INVITE_PATTERN.matcher(getContentRaw());</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">      while (m.find()) invites.add(m.group(1));</span>
<span class="nc" id="L502">      return invites = Collections.unmodifiableList(invites);</span>
    }
  }

  @Override
  public String getNonce() {
<span class="nc" id="L508">    return nonce;</span>
  }

  @Override
  public boolean isFromType(ChannelType type) {
<span class="nc bnc" id="L513" title="All 2 branches missed.">    return getChannelType() == type;</span>
  }

  @Override
  public ChannelType getChannelType() {
<span class="nc" id="L518">    return channel.getType();</span>
  }

  @Override
  public MessageChannel getChannel() {
<span class="nc" id="L523">    return channel;</span>
  }

  @Override
  public PrivateChannel getPrivateChannel() {
<span class="nc bnc" id="L528" title="All 2 branches missed.">    return isFromType(ChannelType.PRIVATE) ? (PrivateChannel) channel : null;</span>
  }

  @Override
  public Group getGroup() {
<span class="nc bnc" id="L533" title="All 2 branches missed.">    return isFromType(ChannelType.GROUP) ? (Group) channel : null;</span>
  }

  @Override
  public TextChannel getTextChannel() {
<span class="nc bnc" id="L538" title="All 2 branches missed.">    return isFromType(ChannelType.TEXT) ? (TextChannel) channel : null;</span>
  }

  @Override
  public Category getCategory() {
<span class="nc bnc" id="L543" title="All 2 branches missed.">    return isFromType(ChannelType.TEXT) ? getTextChannel().getParent() : null;</span>
  }

  @Override
  public Guild getGuild() {
<span class="nc bnc" id="L548" title="All 2 branches missed.">    return isFromType(ChannelType.TEXT) ? getTextChannel().getGuild() : null;</span>
  }

  @Override
  public List&lt;Attachment&gt; getAttachments() {
<span class="nc" id="L553">    return attachments;</span>
  }

  @Override
  public List&lt;MessageEmbed&gt; getEmbeds() {
<span class="nc" id="L558">    return embeds;</span>
  }

  @Override
  public synchronized List&lt;Emote&gt; getEmotes() {
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (this.emoteMentions == null) {</span>
<span class="nc" id="L564">      emoteMentions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L565">      Matcher matcher = MentionType.EMOTE.getPattern().matcher(getContentRaw());</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">      while (matcher.find()) {</span>
        try {
<span class="nc" id="L568">          final long emoteId = MiscUtil.parseSnowflake(matcher.group(2));</span>
<span class="nc" id="L569">          final String emoteName = matcher.group(1);</span>
          // Check animated by verifying whether or not it starts with &lt;a: or &lt;:
<span class="nc" id="L571">          final boolean animated = matcher.group(0).startsWith(&quot;&lt;a:&quot;);</span>

<span class="nc" id="L573">          Emote emote = getJDA().getEmoteById(emoteId);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">          if (emote == null)</span>
<span class="nc" id="L575">            emote = new EmoteImpl(emoteId, api).setAnimated(animated).setName(emoteName);</span>
<span class="nc" id="L576">          emoteMentions.add(emote);</span>
<span class="nc" id="L577">        } catch (NumberFormatException ignored) {</span>
<span class="nc" id="L578">        }</span>
      }
<span class="nc" id="L580">      emoteMentions = Collections.unmodifiableList(emoteMentions);</span>
    }
<span class="nc" id="L582">    return emoteMentions;</span>
  }

  @Override
  public List&lt;MessageReaction&gt; getReactions() {
<span class="nc" id="L587">    return reactions;</span>
  }

  @Override
  public boolean isWebhookMessage() {
<span class="nc" id="L592">    return fromWebhook;</span>
  }

  @Override
  public boolean isTTS() {
<span class="nc" id="L597">    return isTTS;</span>
  }

  @Override
  public MessageAction editMessage(CharSequence newContent) {
<span class="nc" id="L602">    return editMessage(new MessageBuilder().append(newContent).build());</span>
  }

  @Override
  public MessageAction editMessage(MessageEmbed newContent) {
<span class="nc" id="L607">    return editMessage(new MessageBuilder().setEmbed(newContent).build());</span>
  }

  @Override
  public MessageAction editMessageFormat(String format, Object... args) {
<span class="nc" id="L612">    Checks.notBlank(format, &quot;Format String&quot;);</span>
<span class="nc" id="L613">    return editMessage(new MessageBuilder().appendFormat(format, args).build());</span>
  }

  @Override
  public MessageAction editMessage(Message newContent) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">    if (!getJDA().getSelfUser().equals(getAuthor()))</span>
<span class="nc" id="L619">      throw new IllegalStateException(</span>
          &quot;Attempted to update message that was not sent by this account. You cannot modify other User's messages!&quot;);

<span class="nc" id="L622">    return getChannel().editMessageById(getIdLong(), newContent);</span>
  }

  @Override
  public AuditableRestAction&lt;Void&gt; delete() {
<span class="nc bnc" id="L627" title="All 2 branches missed.">    if (!getJDA().getSelfUser().equals(getAuthor())) {</span>
<span class="nc bnc" id="L628" title="All 4 branches missed.">      if (isFromType(ChannelType.PRIVATE) || isFromType(ChannelType.GROUP))</span>
<span class="nc" id="L629">        throw new IllegalStateException(</span>
            &quot;Cannot delete another User's messages in a Group or PrivateChannel.&quot;);
<span class="nc" id="L631">      else if (!getGuild()</span>
<span class="nc" id="L632">          .getSelfMember()</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">          .hasPermission((TextChannel) getChannel(), Permission.MESSAGE_MANAGE))</span>
<span class="nc" id="L634">        throw new InsufficientPermissionException(Permission.MESSAGE_MANAGE);</span>
    }
<span class="nc" id="L636">    return channel.deleteMessageById(getIdLong());</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L641" title="All 2 branches missed.">    if (!(o instanceof ReceivedMessage)) return false;</span>
<span class="nc" id="L642">    ReceivedMessage oMsg = (ReceivedMessage) o;</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">    return this == oMsg || this.id == oMsg.id;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L648">    return Long.hashCode(id);</span>
  }

  @Override
  public String toString() {
<span class="nc bnc" id="L653" title="All 2 branches missed.">    return author != null</span>
<span class="nc" id="L654">        ? String.format(&quot;M:%#s:%.20s(%s)&quot;, author, this, getId())</span>
<span class="nc" id="L655">        : String.format(&quot;M:%.20s&quot;, this); // this message was made using MessageBuilder</span>
  }

  @Override
  protected void unsupported() {
<span class="nc" id="L660">    throw new UnsupportedOperationException(</span>
        &quot;This operation is not supported on received messages!&quot;);
  }

  private boolean hasPermission(Permission permission) {
<span class="nc bnc" id="L665" title="All 2 branches missed.">    switch (channel.getType()) {</span>
      case TEXT:
<span class="nc" id="L667">        return getMember().hasPermission(getTextChannel(), permission);</span>
      default:
<span class="nc" id="L669">        return true;</span>
    }
  }

  private void checkPermission(Permission permission) {
<span class="nc bnc" id="L674" title="All 2 branches missed.">    if (channel.getType() == ChannelType.TEXT) {</span>
<span class="nc" id="L675">      Channel location = (Channel) channel;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">      if (!location.getGuild().getSelfMember().hasPermission(location, permission))</span>
<span class="nc" id="L677">        throw new InsufficientPermissionException(permission);</span>
    }
<span class="nc" id="L679">  }</span>

  private void checkFake(IFakeable o, String name) {
<span class="nc bnc" id="L682" title="All 2 branches missed.">    if (o.isFake())</span>
<span class="nc" id="L683">      throw new IllegalArgumentException(</span>
          &quot;We are unable to use a fake &quot; + name + &quot; in this situation!&quot;);
<span class="nc" id="L685">  }</span>

  @Override
  public void formatTo(Formatter formatter, int flags, int width, int precision) {
<span class="nc bnc" id="L689" title="All 2 branches missed.">    boolean upper = (flags &amp; FormattableFlags.UPPERCASE) == FormattableFlags.UPPERCASE;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">    boolean leftJustified =</span>
        (flags &amp; FormattableFlags.LEFT_JUSTIFY) == FormattableFlags.LEFT_JUSTIFY;
<span class="nc bnc" id="L692" title="All 2 branches missed.">    boolean alt = (flags &amp; FormattableFlags.ALTERNATE) == FormattableFlags.ALTERNATE;</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">    String out = alt ? getContentRaw() : getContentDisplay();</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">    if (upper) out = out.toUpperCase(formatter.locale());</span>

<span class="nc" id="L698">    appendFormat(formatter, width, precision, leftJustified, out);</span>
<span class="nc" id="L699">  }</span>

  private static class FormatToken {
    public final String format;
    public final int start;

<span class="nc" id="L705">    public FormatToken(String format, int start) {</span>
<span class="nc" id="L706">      this.format = format;</span>
<span class="nc" id="L707">      this.start = start;</span>
<span class="nc" id="L708">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>