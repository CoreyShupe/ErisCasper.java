<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MiscUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.utils</a> &gt; <span class="el_source">MiscUtil.java</span></div><h1>MiscUtil.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.utils;

import gnu.trove.impl.sync.TSynchronizedLongObjectMap;
import gnu.trove.map.TLongObjectMap;
import gnu.trove.map.hash.TLongObjectHashMap;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Formatter;
import java.util.TimeZone;
import net.dv8tion.jda.core.entities.Guild;
import net.dv8tion.jda.core.entities.ISnowflake;
import okhttp3.MediaType;
import okhttp3.RequestBody;
import okio.BufferedSink;
import okio.Okio;
import okio.Source;

<span class="nc" id="L39">public class MiscUtil {</span>
  public static final long DISCORD_EPOCH = 1420070400000L;
  public static final long TIMESTAMP_OFFSET = 22;
<span class="nc" id="L42">  private static final DateTimeFormatter dtFormatter = DateTimeFormatter.RFC_1123_DATE_TIME;</span>

  /**
   * Converts the provided epoch millisecond timestamp to a Discord Snowflake. &lt;br&gt;
   * This can be used as a marker/pivot for {@link net.dv8tion.jda.core.entities.MessageHistory
   * MessageHistory} creation.
   *
   * @param millisTimestamp The epoch millis to convert
   * @return Shifted epoch millis for Discord
   */
  public static long getDiscordTimestamp(long millisTimestamp) {
<span class="nc" id="L53">    return (millisTimestamp &lt;&lt; TIMESTAMP_OFFSET) + DISCORD_EPOCH;</span>
  }

  /**
   * Gets the creation-time of a JDA-entity by doing the reverse snowflake algorithm on its id. This
   * returns the creation-time of the actual entity on Discords side, not inside JDA.
   *
   * @param entityId The id of the JDA entity where the creation-time should be determined for
   * @return The creation time of the JDA entity as OffsetDateTime
   */
  public static OffsetDateTime getCreationTime(long entityId) {
<span class="nc" id="L64">    long timestamp = (entityId &gt;&gt;&gt; TIMESTAMP_OFFSET) + DISCORD_EPOCH;</span>
<span class="nc" id="L65">    Calendar gmt = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L66">    gmt.setTimeInMillis(timestamp);</span>
<span class="nc" id="L67">    return OffsetDateTime.ofInstant(gmt.toInstant(), gmt.getTimeZone().toZoneId());</span>
  }

  /**
   * Gets the creation-time of a JDA-entity by doing the reverse snowflake algorithm on its id. This
   * returns the creation-time of the actual entity on Discords side, not inside JDA.
   *
   * @param entity The JDA entity where the creation-time should be determined for
   * @throws IllegalArgumentException If the provided entity is {@code null}
   * @return The creation time of the JDA entity as OffsetDateTime
   */
  public static OffsetDateTime getCreationTime(ISnowflake entity) {
<span class="nc" id="L79">    Checks.notNull(entity, &quot;Entity&quot;);</span>
<span class="nc" id="L80">    return getCreationTime(entity.getIdLong());</span>
  }

  /**
   * Returns a prettier String-representation of a OffsetDateTime object
   *
   * @param time The OffsetDateTime object to format
   * @return The String of the formatted OffsetDateTime
   */
  public static String getDateTimeString(OffsetDateTime time) {
<span class="nc" id="L90">    return time.format(dtFormatter);</span>
  }

  /**
   * Returns the shard id the given guild will be loaded on for the given amount of shards.
   *
   * &lt;p&gt;Discord determines which guilds a shard is connect to using the following format: {@code
   * shardId == (guildId &gt;&gt;&gt; 22) % totalShards} &lt;br&gt;
   * Source for formula: &lt;a
   * href=&quot;https://discordapp.com/developers/docs/topics/gateway#sharding&quot;&gt;Discord Documentation&lt;/a&gt;
   *
   * @param guildId The guild id.
   * @param shards The amount of shards.
   * @return The shard id for the guild.
   */
  public static int getShardForGuild(long guildId, int shards) {
<span class="nc" id="L106">    return (int) ((guildId &gt;&gt;&gt; 22) % shards);</span>
  }

  /**
   * Returns the shard id the given guild will be loaded on for the given amount of shards.
   *
   * &lt;p&gt;Discord determines which guilds a shard is connect to using the following format: {@code
   * shardId == (guildId &gt;&gt;&gt; 22) % totalShards} &lt;br&gt;
   * Source for formula: &lt;a
   * href=&quot;https://discordapp.com/developers/docs/topics/gateway#sharding&quot;&gt;Discord Documentation&lt;/a&gt;
   *
   * @param guildId The guild id.
   * @param shards The amount of shards.
   * @return The shard id for the guild.
   */
  public static int getShardForGuild(String guildId, int shards) {
<span class="nc" id="L122">    return getShardForGuild(parseSnowflake(guildId), shards);</span>
  }

  /**
   * Returns the shard id the given {@link net.dv8tion.jda.core.entities.Guild Guild} will be loaded
   * on for the given amount of shards.
   *
   * &lt;p&gt;Discord determines which guilds a shard is connect to using the following format: {@code
   * shardId == (guildId &gt;&gt;&gt; 22) % totalShards} &lt;br&gt;
   * Source for formula: &lt;a
   * href=&quot;https://discordapp.com/developers/docs/topics/gateway#sharding&quot;&gt;Discord Documentation&lt;/a&gt;
   *
   * @param guild The guild.
   * @param shards The amount of shards.
   * @return The shard id for the guild.
   */
  public static int getShardForGuild(Guild guild, int shards) {
<span class="nc" id="L139">    return getShardForGuild(guild.getIdLong(), shards);</span>
  }

  /**
   * Generates a new thread-safe {@link gnu.trove.map.TLongObjectMap TLongObjectMap}
   *
   * @param  &lt;T&gt; The Object type
   * @return a new thread-safe {@link gnu.trove.map.TLongObjectMap TLongObjectMap}
   */
  public static &lt;T&gt; TLongObjectMap&lt;T&gt; newLongMap() {
<span class="nc" id="L149">    return new TSynchronizedLongObjectMap&lt;&gt;(new TLongObjectHashMap&lt;T&gt;(), new Object());</span>
  }

  /**
   * URL-Encodes the given String to UTF-8 after form-data specifications (space {@literal -&gt;} +)
   *
   * @param chars The characters to encode
   * @return The encoded String
   */
  public static String encodeUTF8(String chars) {
    try {
<span class="nc" id="L160">      return URLEncoder.encode(chars, &quot;UTF-8&quot;);</span>
<span class="nc" id="L161">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L162">      throw new AssertionError(e); // thanks JDK 1.4</span>
    }
  }

  public static long parseSnowflake(String input) {
<span class="nc" id="L167">    Checks.notEmpty(input, &quot;ID&quot;);</span>
    try {
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (!input.startsWith(&quot;-&quot;)) // if not negative -&gt; parse unsigned</span>
<span class="nc" id="L170">      return Long.parseUnsignedLong(input);</span>
      else // if negative -&gt; parse normal
<span class="nc" id="L172">      return Long.parseLong(input);</span>
<span class="nc" id="L173">    } catch (NumberFormatException ex) {</span>
<span class="nc" id="L174">      throw new NumberFormatException(</span>
<span class="nc" id="L175">          String.format(</span>
              &quot;The specified ID is not a valid snowflake (%s). Expecting a valid long value!&quot;,
              input));
    }
  }

  /**
   * Can be used to append a String to a formatter.
   *
   * @param formatter The {@link java.util.Formatter Formatter}
   * @param width Minimum width to meet, filled with space if needed
   * @param precision Maximum amount of characters to append
   * @param leftJustified Whether or not to left-justify the value
   * @param out The String to append
   */
  public static void appendTo(
      Formatter formatter, int width, int precision, boolean leftJustified, String out) {
    try {
<span class="nc" id="L193">      Appendable appendable = formatter.out();</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">      if (precision &gt; -1 &amp;&amp; out.length() &gt; precision) {</span>
<span class="nc" id="L195">        appendable.append(Helpers.truncate(out, precision));</span>
<span class="nc" id="L196">        return;</span>
      }

<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (leftJustified) appendable.append(Helpers.rightPad(out, width));</span>
<span class="nc" id="L200">      else appendable.append(Helpers.leftPad(out, width));</span>
<span class="nc" id="L201">    } catch (IOException e) {</span>
<span class="nc" id="L202">      throw new AssertionError(e);</span>
<span class="nc" id="L203">    }</span>
<span class="nc" id="L204">  }</span>

  /**
   * Creates a new request body that transmits the provided {@link java.io.InputStream InputStream}.
   *
   * @param contentType The {@link okhttp3.MediaType MediaType} of the data
   * @param stream The {@link java.io.InputStream InputStream} to be transmitted
   * @return RequestBody capable of transmitting the provided InputStream of data
   */
  public static RequestBody createRequestBody(
      final MediaType contentType, final InputStream stream) {
<span class="nc" id="L215">    return new RequestBody() {</span>
      @Override
      public MediaType contentType() {
<span class="nc" id="L218">        return contentType;</span>
      }

      @Override
      public void writeTo(BufferedSink sink) throws IOException {
<span class="nc" id="L223">        try (Source source = Okio.source(stream)) {</span>
<span class="nc" id="L224">          sink.writeAll(source);</span>
        }
<span class="nc" id="L226">      }</span>
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>