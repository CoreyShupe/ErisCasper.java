<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RestAction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.requests</a> &gt; <span class="el_source">RestAction.java</span></div><h1>RestAction.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.requests;

import java.util.concurrent.*;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.exceptions.ErrorResponseException;
import net.dv8tion.jda.core.exceptions.PermissionException;
import net.dv8tion.jda.core.exceptions.RateLimitedException;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.JDALogger;
import okhttp3.RequestBody;
import org.apache.commons.collections4.map.CaseInsensitiveMap;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;

/**
 * A class representing a terminal between the user and the discord API. &lt;br&gt;
 * This is used to offer users the ability to decide how JDA should limit a Request.
 *
 * &lt;p&gt;Methods that return an instance of RestAction require an additional step to complete the
 * execution. Thus the user needs to append a follow-up method.
 *
 * &lt;p&gt;A default RestAction is issued with the following operations:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #queue()}, {@link #queue(Consumer)}, {@link #queue(Consumer, Consumer)} &lt;br&gt;
 *       The fastest and most simplistic way to execute a RestAction is to queue it. &lt;br&gt;
 *       This method has two optional callback functions, one with the generic type and another with
 *       a failure exception.
 *   &lt;li&gt;{@link #submit()}, {@link #submit(boolean)} &lt;br&gt;
 *       Provides a Future representing the pending request. &lt;br&gt;
 *       An optional parameter of type boolean can be passed to disable automated rate limit
 *       handling. (not recommended)
 *   &lt;li&gt;{@link #complete()}, {@link #complete(boolean)} &lt;br&gt;
 *       Blocking execution building up on {@link #submit()}. &lt;br&gt;
 *       This will simply block the thread and return the Request result, or throw an exception.
 *       &lt;br&gt;
 *       An optional parameter of type boolean can be passed to disable automated rate limit
 *       handling. (not recommended)
 * &lt;/ul&gt;
 *
 * The most efficient way to use a RestAction is by using the asynchronous {@link #queue()}
 * operations. &lt;br&gt;
 * These allow users to provide success and failure callbacks which will be called at a convenient
 * time.
 *
 * &lt;h2&gt;Planning Execution&lt;/h2&gt;
 *
 * To &lt;u&gt;schedule&lt;/u&gt; a RestAction we provide both {@link #queue()} and {@link #complete()} versions
 * that will be executed by a {@link java.util.concurrent.ScheduledExecutorService
 * ScheduledExecutorService} after a specified delay:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #queueAfter(long, TimeUnit)} &lt;br&gt;
 *       Schedules a call to {@link #queue()} with default callback {@link
 *       java.util.function.Consumer Consumers} to be executed after the specified {@code delay}.
 *       &lt;br&gt;
 *       The {@link java.util.concurrent.TimeUnit TimeUnit} is used to convert the provided long
 *       into a delay time. &lt;br&gt;
 *       Example: {@code queueAfter(1, TimeUnit.SECONDS);} &lt;br&gt;
 *       will call {@link #queue()} &lt;b&gt;1 second&lt;/b&gt; later.
 *   &lt;li&gt;{@link #submitAfter(long, TimeUnit)} &lt;br&gt;
 *       This returns a {@link java.util.concurrent.ScheduledFuture ScheduledFuture} which can be
 *       joined into the current Thread using {@link java.util.concurrent.ScheduledFuture#get()}
 *       &lt;br&gt;
 *       The blocking call to {@code submitAfter(delay, unit).get()} will return the value processed
 *       by a call to {@link #complete()}
 *   &lt;li&gt;{@link #completeAfter(long, TimeUnit)} &lt;br&gt;
 *       This operation simply sleeps for the given delay and will call {@link #complete()} once
 *       finished sleeping.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All of those operations provide overloads for optional parameters such as a custom {@link
 * java.util.concurrent.ScheduledExecutorService ScheduledExecutorService} instead of using the
 * default global JDA executor. Specifically {@link #queueAfter(long, TimeUnit)} has overloads to
 * provide a success and/or failure callback due to the returned {@link
 * java.util.concurrent.ScheduledFuture ScheduledFuture} not being able to provide the response
 * values of the {@link #queue()} callbacks.
 *
 * &lt;h1&gt;Using RestActions&lt;/h1&gt;
 *
 * The most common way to use a RestAction is not using the returned value. &lt;br&gt;
 * For instance sending messages usually means you will not require to view the message once it was
 * sent. Thus we can simply use the &lt;b&gt;asynchronous&lt;/b&gt; {@link #queue()} operation which will be
 * executed on a rate limit worker thread in the background, without blocking your current thread:
 *
 * &lt;pre&gt;&lt;code&gt;
 *      {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} channel = event.getChannel();
 *     {@literal RestAction&lt;Message&gt;} action = channel.sendMessage(&quot;Hello World&quot;);
 *      action.{@link #queue() queue()}; // Execute the rest action asynchronously
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;Sometimes it is important to access the response value, possibly to modify it later. &lt;br&gt;
 * Now we have two options to actually access the response value, either using an asynchronous
 * callback {@link java.util.function.Consumer Consumer} or the (not recommended) {@link
 * #complete()} which will block the current thread until the response has been processed and joins
 * with the current thread.
 *
 * &lt;h2&gt;Example Queue: (recommended)&lt;/h2&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 *     {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} channel = event.getChannel();
 *     final long time = System.currentTimeMillis();
 *    {@literal RestAction&lt;Message&gt;} action = channel.sendMessage(&quot;Calculating Response Time...&quot;);
 *     {@link java.util.function.Consumer Consumer}{@literal &lt;Message&gt;} callback = (message) {@literal -&gt;  {
 *        Message m = message; // ^This is a lambda parameter!^
 *        m.editMessage(&quot;Response Time: &quot; + (System.currentTimeMillis() - time) + &quot;ms&quot;).queue();
 *        // End with queue() to not block the callback thread!
 *      }};
 *     // You can also inline this with the queue parameter: action.queue(m {@literal -&gt;} m.editMessage(...).queue());
 *     action.{@link #queue(Consumer) queue(callback)};
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Example Complete:&lt;/h2&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 *     {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} channel = event.getChannel();
 *     final long time = System.currentTimeMillis();
 *    {@literal RestAction&lt;Message&gt;} action = channel.sendMessage(&quot;Calculating Response Time...&quot;);
 *     Message message = action.{@link #complete() complete()};
 *     message.editMessage(&quot;Response Time: &quot; + (System.currentTimeMillis() - time) + &quot;ms&quot;).queue();
 *     // End with {@link #queue() queue()} to not block the callback thread!
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h2&gt;Example Planning:&lt;/h2&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 *     {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} channel = event.getChannel();
 *    {@literal RestAction&lt;Message&gt;} action = channel.sendMessage(&quot;This message will destroy itself in 5 seconds!&quot;);
 *     action.queue((message) {@literal -&gt;} message.delete().{@link #queueAfter(long, TimeUnit) queueAfter(5, TimeUnit.SECONDS)});
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Developer Note:&lt;/b&gt; It is generally a good practice to use asynchronous logic because
 * blocking threads requires resources which can be avoided by using callbacks over blocking
 * operations: &lt;br&gt;
 * {@link #queue(Consumer)} {@literal &gt;} {@link #complete()}
 *
 * &lt;p&gt;There is a dedicated &lt;a href=&quot;https://github.com/DV8FromTheWorld/JDA/wiki/7)-Using-RestAction&quot;
 * target=&quot;_blank&quot;&gt;wiki page&lt;/a&gt; for RestActions that can be useful for learning.
 *
 * @param &lt;T&gt; The generic response type for this RestAction
 * @since 3.0
 */
public abstract class RestAction&lt;T&gt; {
<span class="nc" id="L164">  public static final Logger LOG = JDALogger.getLog(RestAction.class);</span>

<span class="nc" id="L166">  public static Consumer DEFAULT_SUCCESS = o -&gt; {};</span>
<span class="nc" id="L167">  public static Consumer&lt;Throwable&gt; DEFAULT_FAILURE =</span>
      t -&gt; {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L170">          LOG.error(&quot;RestAction queue returned failure&quot;, t);</span>
        } else {
<span class="nc" id="L172">          LOG.error(</span>
              &quot;RestAction queue returned failure: [{}] {}&quot;,
<span class="nc" id="L174">              t.getClass().getSimpleName(),</span>
<span class="nc" id="L175">              t.getMessage());</span>
        }
<span class="nc" id="L177">      };</span>

<span class="nc" id="L179">  private static final Consumer FALLBACK_CONSUMER = o -&gt; {};</span>

<span class="nc" id="L181">  protected static boolean passContext = false;</span>

  protected final JDAImpl api;

  private final Route.CompiledRoute route;
  private final RequestBody data;

  private Object rawData;
  private BooleanSupplier checks;

  /**
   * If enabled this will pass a {@link net.dv8tion.jda.core.exceptions.ContextException
   * ContextException} as root-cause to all failure consumers. Note that the {@link
   * #DEFAULT_FAILURE} does not print a stack-trace at all unless specified! &lt;br&gt;
   * This might cause performance decrease due to the creation of exceptions for &lt;b&gt;every&lt;/b&gt;
   * execution.
   *
   * &lt;p&gt;It is recommended to pass a context consumer as failure manually using {@code queue(success,
   * ContextException.here(failure))}
   *
   * @param enable True, if context should be passed to all failure consumers
   */
  public static void setPassContext(boolean enable) {
<span class="nc" id="L204">    passContext = enable;</span>
<span class="nc" id="L205">  }</span>

  /**
   * Whether RestActions will use {@link net.dv8tion.jda.core.exceptions.ContextException
   * ContextException} automatically to keep track of the caller context. &lt;br&gt;
   * If set to {@code true} this can cause performance drops due to the creation of stack-traces on
   * execution.
   *
   * @return True, if RestActions will keep track of context automatically
   * @see #setPassContext(boolean)
   */
  public static boolean isPassContext() {
<span class="nc" id="L217">    return passContext;</span>
  }

  /**
   * Creates a new RestAction instance
   *
   * @param api The current JDA instance
   * @param route The {@link net.dv8tion.jda.core.requests.Route.CompiledRoute Route.CompiledRoute}
   *     to be used for rate limit handling
   */
  public RestAction(JDA api, Route.CompiledRoute route) {
<span class="nc" id="L228">    this(api, route, (RequestBody) null);</span>
<span class="nc" id="L229">  }</span>

  /**
   * Creates a new RestAction instance
   *
   * @param api The current JDA instance
   * @param route The {@link net.dv8tion.jda.core.requests.Route.CompiledRoute Route.CompiledRoute}
   *     to be used for rate limit handling
   * @param data The data that should be sent to the specified route. (can be null)
   */
<span class="nc" id="L239">  public RestAction(JDA api, Route.CompiledRoute route, RequestBody data) {</span>
<span class="nc" id="L240">    Checks.notNull(api, &quot;api&quot;);</span>

<span class="nc" id="L242">    this.api = (JDAImpl) api;</span>
<span class="nc" id="L243">    this.route = route;</span>
<span class="nc" id="L244">    this.data = data;</span>
<span class="nc" id="L245">  }</span>

  /**
   * Creates a new RestAction instance
   *
   * @param api The current JDA instance
   * @param route The {@link net.dv8tion.jda.core.requests.Route.CompiledRoute Route.CompiledRoute}
   *     to be used for rate limit handling
   * @param data The data that should be sent to the specified route. (can be null)
   */
  public RestAction(JDA api, Route.CompiledRoute route, JSONObject data) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    this(</span>
        api,
        route,
<span class="nc" id="L259">        data == null ? null : RequestBody.create(Requester.MEDIA_TYPE_JSON, data.toString()));</span>

<span class="nc" id="L261">    this.rawData = data;</span>
<span class="nc" id="L262">  }</span>

  /**
   * The current JDA instance
   *
   * @return The corresponding JDA instance
   */
  public JDA getJDA() {
<span class="nc" id="L270">    return api;</span>
  }

  /**
   * Sets the last-second checks before finally executing the http request in the queue. &lt;br&gt;
   * If the provided supplier evaluates to {@code false} or throws an exception this will not be
   * finished. When an exception is thrown from the supplier it will be provided to the failure
   * callback.
   *
   * @param checks The checks to run before executing the request, or {@code null} to run no checks
   * @return The current RestAction for chaining convenience
   */
  public RestAction&lt;T&gt; setCheck(BooleanSupplier checks) {
<span class="nc" id="L283">    this.checks = checks;</span>
<span class="nc" id="L284">    return this;</span>
  }

  /**
   * Submits a Request for execution. &lt;br&gt;
   * Using the default callback functions: {@link #DEFAULT_SUCCESS DEFAULT_SUCCESS} and {@link
   * #DEFAULT_FAILURE DEFAULT_FAILURE}
   *
   * &lt;p&gt;&lt;b&gt;This method is asynchronous&lt;/b&gt;
   */
  public void queue() {
<span class="nc" id="L295">    queue(null, null);</span>
<span class="nc" id="L296">  }</span>

  /**
   * Submits a Request for execution. &lt;br&gt;
   * Using the default failure callback function.
   *
   * &lt;p&gt;&lt;b&gt;This method is asynchronous&lt;/b&gt;
   *
   * @param success The success callback that will be called at a convenient time for the API. (can
   *     be null)
   */
  public void queue(Consumer&lt;T&gt; success) {
<span class="nc" id="L308">    queue(success, null);</span>
<span class="nc" id="L309">  }</span>

  /**
   * Submits a Request for execution.
   *
   * &lt;p&gt;&lt;b&gt;This method is asynchronous&lt;/b&gt;
   *
   * @param success The success callback that will be called at a convenient time for the API. (can
   *     be null)
   * @param failure The failure callback that will be called if the Request encounters an exception
   *     at its execution point.
   */
  public void queue(Consumer&lt;T&gt; success, Consumer&lt;Throwable&gt; failure) {
<span class="nc" id="L322">    Route.CompiledRoute route = finalizeRoute();</span>
<span class="nc" id="L323">    Checks.notNull(route, &quot;Route&quot;);</span>
<span class="nc" id="L324">    RequestBody data = finalizeData();</span>
<span class="nc" id="L325">    CaseInsensitiveMap&lt;String, String&gt; headers = finalizeHeaders();</span>
<span class="nc" id="L326">    BooleanSupplier finisher = getFinisher();</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">    if (success == null) success = DEFAULT_SUCCESS == null ? FALLBACK_CONSUMER : DEFAULT_SUCCESS;</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">    if (failure == null) failure = DEFAULT_FAILURE == null ? FALLBACK_CONSUMER : DEFAULT_FAILURE;</span>
<span class="nc" id="L329">    api.getRequester()</span>
<span class="nc" id="L330">        .request(</span>
            new Request&lt;&gt;(this, success, failure, finisher, true, data, rawData, route, headers));
<span class="nc" id="L332">  }</span>

  /**
   * Submits a Request for execution and provides a {@link
   * net.dv8tion.jda.core.requests.RequestFuture RequestFuture} representing its completion task.
   * &lt;br&gt;
   * Cancelling the returned Future will result in the cancellation of the Request!
   *
   * &lt;p&gt;Note: The usage of {@link java.util.concurrent.CompletionStage#toCompletableFuture()
   * CompletionStage.toCompletableFuture()} is not supported.
   *
   * @return Never-null {@link net.dv8tion.jda.core.requests.RequestFuture RequestFuture}
   *     representing the completion promise
   */
  public RequestFuture&lt;T&gt; submit() {
<span class="nc" id="L347">    return submit(true);</span>
  }

  /**
   * Submits a Request for execution and provides a {@link
   * net.dv8tion.jda.core.requests.RequestFuture RequestFuture} representing its completion task.
   * &lt;br&gt;
   * Cancelling the returned Future will result in the cancellation of the Request!
   *
   * &lt;p&gt;Note: The usage of {@link java.util.concurrent.CompletionStage#toCompletableFuture()
   * CompletionStage.toCompletableFuture()} is not supported.
   *
   * @param shouldQueue Whether the Request should automatically handle rate limitations. (default
   *     true)
   * @return Never-null {@link net.dv8tion.jda.core.requests.RequestFuture RequestFuture} task
   *     representing the completion promise
   */
  public RequestFuture&lt;T&gt; submit(boolean shouldQueue) {
<span class="nc" id="L365">    Route.CompiledRoute route = finalizeRoute();</span>
<span class="nc" id="L366">    Checks.notNull(route, &quot;Route&quot;);</span>
<span class="nc" id="L367">    RequestBody data = finalizeData();</span>
<span class="nc" id="L368">    CaseInsensitiveMap&lt;String, String&gt; headers = finalizeHeaders();</span>
<span class="nc" id="L369">    BooleanSupplier finisher = getFinisher();</span>
<span class="nc" id="L370">    return new RestFuture&lt;&gt;(this, shouldQueue, finisher, data, rawData, route, headers);</span>
  }

  /**
   * Blocks the current Thread and awaits the completion of an {@link #submit()} request. &lt;br&gt;
   * Used for synchronous logic.
   *
   * &lt;p&gt;&lt;b&gt;This might throw {@link java.lang.RuntimeException RuntimeExceptions}&lt;/b&gt;
   *
   * @return The response value
   */
  public T complete() {
    try {
<span class="nc" id="L383">      return complete(true);</span>
<span class="nc" id="L384">    } catch (RateLimitedException ignored) {</span>
      // This is so beyond impossible, but on the off chance that the laws of nature are rewritten
      // after the writing of this code, I'm placing this here.
      // Better safe than sorry?
<span class="nc" id="L388">      throw new AssertionError(ignored);</span>
    }
  }

  /**
   * Blocks the current Thread and awaits the completion of an {@link #submit()} request. &lt;br&gt;
   * Used for synchronous logic.
   *
   * @param shouldQueue Whether this should automatically handle rate limitations (default true)
   * @throws RateLimitedException If we were rate limited and the {@code shouldQueue} is false. Use
   *     {@link #complete()} to avoid this Exception.
   * @return The response value
   */
  public T complete(boolean shouldQueue) throws RateLimitedException {
    try {
<span class="nc" id="L403">      return submit(shouldQueue).get();</span>
<span class="nc" id="L404">    } catch (Throwable e) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (e instanceof ExecutionException) {</span>
<span class="nc" id="L406">        Throwable t = e.getCause();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (t instanceof RateLimitedException) throw (RateLimitedException) t;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        else if (t instanceof PermissionException) throw (PermissionException) t;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        else if (t instanceof ErrorResponseException) throw (ErrorResponseException) t;</span>
      }
<span class="nc" id="L411">      throw new RuntimeException(e);</span>
    }
  }

  /**
   * Schedules a call to {@link #complete()} to be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;The returned Future will provide the return type of a {@link #complete()} operation when
   * received through the &lt;b&gt;blocking&lt;/b&gt; call to {@link java.util.concurrent.Future#get()}!
   *
   * &lt;p&gt;The global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} is used for this operation. &lt;br&gt;
   * You can change the core pool size for this Executor through {@link
   * net.dv8tion.jda.core.JDABuilder#setCorePoolSize(int) JDABuilder.setCorePoolSize(int)} or you
   * can provide your own Executor using {@link #submitAfter(long, java.util.concurrent.TimeUnit,
   * java.util.concurrent.ScheduledExecutorService)}!
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;T&gt; submitAfter(long delay, TimeUnit unit) {
<span class="nc" id="L439">    return submitAfter(delay, unit, api.pool);</span>
  }

  /**
   * Schedules a call to {@link #complete()} to be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;The returned Future will provide the return type of a {@link #complete()} operation when
   * received through the &lt;b&gt;blocking&lt;/b&gt; call to {@link java.util.concurrent.Future#get()}!
   *
   * &lt;p&gt;The specified {@link java.util.concurrent.ScheduledExecutorService ScheduledExecutorService}
   * is used for this operation.
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param executor The Non-null {@link java.util.concurrent.ScheduledExecutorService
   *     ScheduledExecutorService} that should be used to schedule this operation
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit or ScheduledExecutorService
   *     is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;T&gt; submitAfter(
      long delay, TimeUnit unit, ScheduledExecutorService executor) {
<span class="nc" id="L466">    Checks.notNull(executor, &quot;Scheduler&quot;);</span>
<span class="nc" id="L467">    Checks.notNull(unit, &quot;TimeUnit&quot;);</span>
<span class="nc" id="L468">    return executor.schedule((Callable&lt;T&gt;) this::complete, delay, unit);</span>
  }

  /**
   * Blocks the current Thread for the specified delay and calls {@link #complete()} when delay has
   * been reached. &lt;br&gt;
   * If the specified delay is negative this action will execute immediately. (see: {@link
   * TimeUnit#sleep(long)})
   *
   * @param delay The delay after which to execute a call to {@link #complete()}
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} which should be used (this will
   *     use {@link java.util.concurrent.TimeUnit#sleep(long) unit.sleep(delay)})
   * @throws java.lang.IllegalArgumentException If the specified {@link
   *     java.util.concurrent.TimeUnit TimeUnit} is {@code null}
   * @throws java.lang.RuntimeException If the sleep operation is interrupted
   * @return The response value
   */
  public T completeAfter(long delay, TimeUnit unit) {
<span class="nc" id="L486">    Checks.notNull(unit, &quot;TimeUnit&quot;);</span>
    try {
<span class="nc" id="L488">      unit.sleep(delay);</span>
<span class="nc" id="L489">      return complete();</span>
<span class="nc" id="L490">    } catch (InterruptedException e) {</span>
<span class="nc" id="L491">      throw new RuntimeException(e);</span>
    }
  }

  /**
   * Schedules a call to {@link #queue()} to be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;This operation gives no access to the response value. &lt;br&gt;
   * Use {@link #queueAfter(long, java.util.concurrent.TimeUnit, java.util.function.Consumer)} to
   * access the success consumer for {@link #queue(java.util.function.Consumer)}!
   *
   * &lt;p&gt;The global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} is used for this operation. &lt;br&gt;
   * You can change the core pool size for this Executor through {@link
   * net.dv8tion.jda.core.JDABuilder#setCorePoolSize(int) JDABuilder.setCorePoolSize(int)} or
   * provide your own Executor with {@link #queueAfter(long, java.util.concurrent.TimeUnit,
   * java.util.concurrent.ScheduledExecutorService)}
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(long delay, TimeUnit unit) {
<span class="nc" id="L520">    return queueAfter(delay, unit, api.pool);</span>
  }

  /**
   * Schedules a call to {@link #queue(java.util.function.Consumer)} to be executed after the
   * specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;This operation gives no access to the failure callback. &lt;br&gt;
   * Use {@link #queueAfter(long, java.util.concurrent.TimeUnit, java.util.function.Consumer,
   * java.util.function.Consumer)} to access the failure consumer for {@link
   * #queue(java.util.function.Consumer, java.util.function.Consumer)}!
   *
   * &lt;p&gt;The global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} is used for this operation. &lt;br&gt;
   * You can change the core pool size for this Executor through {@link
   * net.dv8tion.jda.core.JDABuilder#setCorePoolSize(int) JDABuilder.setCorePoolSize(int)} or
   * provide your own Executor with {@link #queueAfter(long, java.util.concurrent.TimeUnit,
   * java.util.function.Consumer, java.util.concurrent.ScheduledExecutorService)}
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param success The success {@link java.util.function.Consumer Consumer} that should be called
   *     once the {@link #queue(java.util.function.Consumer)} operation completes successfully.
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(long delay, TimeUnit unit, Consumer&lt;T&gt; success) {
<span class="nc" id="L552">    return queueAfter(delay, unit, success, api.pool);</span>
  }

  /**
   * Schedules a call to {@link #queue(java.util.function.Consumer, java.util.function.Consumer)} to
   * be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;The global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} is used for this operation. &lt;br&gt;
   * You can change the core pool size for this Executor through {@link
   * net.dv8tion.jda.core.JDABuilder#setCorePoolSize(int) JDABuilder.setCorePoolSize(int)} or
   * provide your own Executor with {@link #queueAfter(long, java.util.concurrent.TimeUnit,
   * java.util.function.Consumer, java.util.function.Consumer,
   * java.util.concurrent.ScheduledExecutorService)}
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param success The success {@link java.util.function.Consumer Consumer} that should be called
   *     once the {@link #queue(java.util.function.Consumer, java.util.function.Consumer)} operation
   *     completes successfully.
   * @param failure The failure {@link java.util.function.Consumer Consumer} that should be called
   *     in case of an error of the {@link #queue(java.util.function.Consumer,
   *     java.util.function.Consumer)} operation.
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(
      long delay, TimeUnit unit, Consumer&lt;T&gt; success, Consumer&lt;Throwable&gt; failure) {
<span class="nc" id="L585">    return queueAfter(delay, unit, success, failure, api.pool);</span>
  }

  /**
   * Schedules a call to {@link #queue()} to be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;This operation gives no access to the response value. &lt;br&gt;
   * Use {@link #queueAfter(long, java.util.concurrent.TimeUnit, java.util.function.Consumer)} to
   * access the success consumer for {@link #queue(java.util.function.Consumer)}!
   *
   * &lt;p&gt;The specified {@link java.util.concurrent.ScheduledExecutorService ScheduledExecutorService}
   * is used for this operation.
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param executor The Non-null {@link java.util.concurrent.ScheduledExecutorService
   *     ScheduledExecutorService} that should be used to schedule this operation
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit or ScheduledExecutorService
   *     is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(
      long delay, TimeUnit unit, ScheduledExecutorService executor) {
<span class="nc" id="L613">    return queueAfter(delay, unit, null, executor);</span>
  }

  /**
   * Schedules a call to {@link #queue(java.util.function.Consumer)} to be executed after the
   * specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;This operation gives no access to the failure callback. &lt;br&gt;
   * Use {@link #queueAfter(long, java.util.concurrent.TimeUnit, java.util.function.Consumer,
   * java.util.function.Consumer)} to access the failure consumer for {@link
   * #queue(java.util.function.Consumer, java.util.function.Consumer)}!
   *
   * &lt;p&gt;The specified {@link java.util.concurrent.ScheduledExecutorService ScheduledExecutorService}
   * is used for this operation.
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param success The success {@link java.util.function.Consumer Consumer} that should be called
   *     once the {@link #queue(java.util.function.Consumer)} operation completes successfully.
   * @param executor The Non-null {@link java.util.concurrent.ScheduledExecutorService
   *     ScheduledExecutorService} that should be used to schedule this operation
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit or ScheduledExecutorService
   *     is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(
      long delay, TimeUnit unit, Consumer&lt;T&gt; success, ScheduledExecutorService executor) {
<span class="nc" id="L645">    return queueAfter(delay, unit, success, null, executor);</span>
  }

  /**
   * Schedules a call to {@link #queue(java.util.function.Consumer, java.util.function.Consumer)} to
   * be executed after the specified {@code delay}. &lt;br&gt;
   * This is an &lt;b&gt;asynchronous&lt;/b&gt; operation that will return a {@link
   * java.util.concurrent.ScheduledFuture ScheduledFuture} representing the task.
   *
   * &lt;p&gt;The specified {@link java.util.concurrent.ScheduledExecutorService ScheduledExecutorService}
   * is used for this operation.
   *
   * @param delay The delay after which this computation should be executed, negative to execute
   *     immediately
   * @param unit The {@link java.util.concurrent.TimeUnit TimeUnit} to convert the specified {@code
   *     delay}
   * @param success The success {@link java.util.function.Consumer Consumer} that should be called
   *     once the {@link #queue(java.util.function.Consumer, java.util.function.Consumer)} operation
   *     completes successfully.
   * @param failure The failure {@link java.util.function.Consumer Consumer} that should be called
   *     in case of an error of the {@link #queue(java.util.function.Consumer,
   *     java.util.function.Consumer)} operation.
   * @param executor The Non-null {@link java.util.concurrent.ScheduledExecutorService
   *     ScheduledExecutorService} that should be used to schedule this operation
   * @throws java.lang.IllegalArgumentException If the provided TimeUnit or ScheduledExecutorService
   *     is {@code null}
   * @return {@link java.util.concurrent.ScheduledFuture ScheduledFuture} representing the delayed
   *     operation
   */
  public ScheduledFuture&lt;?&gt; queueAfter(
      long delay,
      TimeUnit unit,
      Consumer&lt;T&gt; success,
      Consumer&lt;Throwable&gt; failure,
      ScheduledExecutorService executor) {
<span class="nc" id="L680">    Checks.notNull(executor, &quot;Scheduler&quot;);</span>
<span class="nc" id="L681">    Checks.notNull(unit, &quot;TimeUnit&quot;);</span>
<span class="nc" id="L682">    return executor.schedule(() -&gt; queue(success, failure), delay, unit);</span>
  }

  protected RequestBody finalizeData() {
<span class="nc" id="L686">    return data;</span>
  }

  protected Route.CompiledRoute finalizeRoute() {
<span class="nc" id="L690">    return route;</span>
  }

  protected CaseInsensitiveMap&lt;String, String&gt; finalizeHeaders() {
<span class="nc" id="L694">    return null;</span>
  }

  protected BooleanSupplier finalizeChecks() {
<span class="nc" id="L698">    return null;</span>
  }

  protected RequestBody getRequestBody(JSONObject object) {
<span class="nc" id="L702">    this.rawData = object;</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">    return object == null ? null : RequestBody.create(Requester.MEDIA_TYPE_JSON, object.toString());</span>
  }

  protected RequestBody getRequestBody(JSONArray array) {
<span class="nc" id="L708">    this.rawData = array;</span>

<span class="nc bnc" id="L710" title="All 2 branches missed.">    return array == null ? null : RequestBody.create(Requester.MEDIA_TYPE_JSON, array.toString());</span>
  }

  private CheckWrapper getFinisher() {
<span class="nc" id="L714">    BooleanSupplier pre = finalizeChecks();</span>
<span class="nc" id="L715">    BooleanSupplier wrapped = this.checks;</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">    return (pre != null || wrapped != null) ? new CheckWrapper(wrapped, pre) : CheckWrapper.EMPTY;</span>
  }

  protected abstract void handleResponse(Response response, Request&lt;T&gt; request);

  /**
   * Specialized form of {@link net.dv8tion.jda.core.requests.RestAction} that is used to provide
   * information that has already been retrieved or generated so that another request does not need
   * to be made to Discord. &lt;br&gt;
   * Basically: Allows you to provide a value directly to the success returns.
   *
   * @param &lt;T&gt; The generic response type for this RestAction
   */
  public static class EmptyRestAction&lt;T&gt; extends RestAction&lt;T&gt; {
    private final T returnObj;

    public EmptyRestAction(JDA api, T returnObj) {
<span class="nc" id="L733">      super(api, null);</span>
<span class="nc" id="L734">      this.returnObj = returnObj;</span>
<span class="nc" id="L735">    }</span>

    @Override
    public void queue(Consumer&lt;T&gt; success, Consumer&lt;Throwable&gt; failure) {
<span class="nc bnc" id="L739" title="All 2 branches missed.">      if (success != null) success.accept(returnObj);</span>
<span class="nc" id="L740">    }</span>

    @Override
    public RequestFuture&lt;T&gt; submit(boolean shouldQueue) {
<span class="nc" id="L744">      return new RestFuture&lt;&gt;(returnObj);</span>
    }

    @Override
    public T complete(boolean shouldQueue) {
<span class="nc" id="L749">      return returnObj;</span>
    }

    @Override
<span class="nc" id="L753">    protected void handleResponse(Response response, Request&lt;T&gt; request) {}</span>
  }

  /*
     useful for final permission checks:

     @Override
     protected BooleanSupplier finalizeChecks()
     {
         // throw exception, if missing perms
         return () -&gt; hasPermission(Permission.MESSAGE_WRITE);
     }
  */
  protected static class CheckWrapper implements BooleanSupplier {
<span class="nc" id="L767">    public static final CheckWrapper EMPTY =</span>
<span class="nc" id="L768">        new CheckWrapper(null, null) {</span>
          public boolean getAsBoolean() {
<span class="nc" id="L770">            return true;</span>
          }
        };

    protected final BooleanSupplier pre;
    protected final BooleanSupplier wrapped;

<span class="nc" id="L777">    public CheckWrapper(BooleanSupplier wrapped, BooleanSupplier pre) {</span>
<span class="nc" id="L778">      this.pre = pre;</span>
<span class="nc" id="L779">      this.wrapped = wrapped;</span>
<span class="nc" id="L780">    }</span>

    public boolean pre() {
<span class="nc bnc" id="L783" title="All 4 branches missed.">      return pre == null || pre.getAsBoolean();</span>
    }

    public boolean test() {
<span class="nc bnc" id="L787" title="All 4 branches missed.">      return wrapped == null || wrapped.getAsBoolean();</span>
    }

    @Override
    public boolean getAsBoolean() {
<span class="nc bnc" id="L792" title="All 4 branches missed.">      return pre() &amp;&amp; test();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>