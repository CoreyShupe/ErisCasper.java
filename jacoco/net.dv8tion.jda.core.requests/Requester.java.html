<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Requester.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.requests</a> &gt; <span class="el_source">Requester.java</span></div><h1>Requester.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.requests;

import java.io.IOException;
import java.io.InputStream;
import java.net.SocketTimeoutException;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.JDAInfo;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.requests.ratelimit.BotRateLimiter;
import okhttp3.Call;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.RequestBody;
import okhttp3.internal.http.HttpMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Requester {

<span class="nc" id="L42">  public static final Logger LOG = LoggerFactory.getLogger(Requester.class);</span>

<span class="nc" id="L44">  public static final String DISCORD_API_PREFIX =</span>
<span class="nc" id="L45">      String.format(&quot;https://discordapp.com/api/v%d/&quot;, JDAInfo.DISCORD_REST_VERSION);</span>
<span class="nc" id="L46">  public static final String USER_AGENT =</span>
      &quot;DiscordBot (&quot; + JDAInfo.GITHUB + &quot;, &quot; + JDAInfo.VERSION + &quot;)&quot;;
<span class="nc" id="L48">  public static final MediaType MEDIA_TYPE_JSON =</span>
<span class="nc" id="L49">      MediaType.parse(&quot;application/json; charset=utf-8&quot;);</span>
<span class="nc" id="L50">  public static final RequestBody EMPTY_BODY = RequestBody.create(null, new byte[] {});</span>

  protected final JDAImpl api;
  private final RateLimiter rateLimiter;

  private final OkHttpClient httpClient;

<span class="nc" id="L57">  private volatile boolean retryOnTimeout = false;</span>

<span class="nc" id="L59">  public Requester(JDA api) {</span>
<span class="nc" id="L60">    this.api = (JDAImpl) api;</span>
<span class="nc" id="L61">    rateLimiter = new BotRateLimiter(this, 5);</span>

<span class="nc" id="L63">    this.httpClient = this.api.getHttpClientBuilder().build();</span>
<span class="nc" id="L64">  }</span>

  public JDAImpl getJDA() {
<span class="nc" id="L67">    return api;</span>
  }

  public &lt;T&gt; void request(Request&lt;T&gt; apiRequest) {
<span class="nc bnc" id="L71" title="All 2 branches missed.">    if (rateLimiter.isShutdown)</span>
<span class="nc" id="L72">      throw new IllegalStateException(</span>
          &quot;The Requester has been shutdown! No new requests can be requested!&quot;);

<span class="nc bnc" id="L75" title="All 2 branches missed.">    if (apiRequest.shouldQueue()) rateLimiter.queueRequest(apiRequest);</span>
<span class="nc" id="L76">    else execute(apiRequest, false, true);</span>
<span class="nc" id="L77">  }</span>

  public Long execute(Request&lt;?&gt; apiRequest) {
<span class="nc" id="L80">    return execute(apiRequest, false, false);</span>
  }

  private Long execute(Request&lt;?&gt; apiRequest, boolean retried, boolean handleOnRatelimit) {
<span class="nc" id="L84">    Route.CompiledRoute route = apiRequest.getRoute();</span>
<span class="nc" id="L85">    Long retryAfter = rateLimiter.getRateLimit(route);</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    if (retryAfter != null) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">      if (handleOnRatelimit)</span>
<span class="nc" id="L88">        apiRequest.handleResponse(new Response(retryAfter, Collections.emptySet()));</span>
<span class="nc" id="L89">      return retryAfter;</span>
    }

<span class="nc" id="L92">    okhttp3.Request.Builder builder = new okhttp3.Request.Builder();</span>

<span class="nc" id="L94">    String url = DISCORD_API_PREFIX + route.getCompiledRoute();</span>
<span class="nc" id="L95">    builder.url(url);</span>

<span class="nc" id="L97">    String method = apiRequest.getRoute().getMethod().toString();</span>
<span class="nc" id="L98">    RequestBody body = apiRequest.getBody();</span>

<span class="nc bnc" id="L100" title="All 4 branches missed.">    if (body == null &amp;&amp; HttpMethod.requiresRequestBody(method)) body = EMPTY_BODY;</span>

<span class="nc" id="L102">    builder.method(method, body).header(&quot;user-agent&quot;, USER_AGENT).header(&quot;accept-encoding&quot;, &quot;gzip&quot;);</span>

    // adding token to all requests to the discord api or cdn pages
    // we can check for startsWith(DISCORD_API_PREFIX) because the cdn endpoints don't need any kind
    // of authorization
<span class="nc bnc" id="L107" title="All 4 branches missed.">    if (url.startsWith(DISCORD_API_PREFIX) &amp;&amp; api.getToken() != null)</span>
<span class="nc" id="L108">      builder.header(&quot;authorization&quot;, api.getToken());</span>

    // Apply custom headers like X-Audit-Log-Reason
    // If customHeaders is null this does nothing
<span class="nc bnc" id="L112" title="All 2 branches missed.">    if (apiRequest.getHeaders() != null) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; header : apiRequest.getHeaders().entrySet())</span>
<span class="nc" id="L114">        builder.addHeader(header.getKey(), header.getValue());</span>
    }

<span class="nc" id="L117">    okhttp3.Request request = builder.build();</span>

<span class="nc" id="L119">    Set&lt;String&gt; rays = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L120">    okhttp3.Response[] responses = new okhttp3.Response[4];</span>
    // we have an array of all responses to later close them all at once
    // the response below this comment is used as the first successful response from the server
<span class="nc" id="L123">    okhttp3.Response firstSuccess = null;</span>
    try {
<span class="nc" id="L125">      int attempt = 0;</span>
      do {
        // If the request has been canceled via the Future, don't execute.
        // if (apiRequest.isCanceled())
        //    return null;
<span class="nc" id="L130">        Call call = httpClient.newCall(request);</span>
<span class="nc" id="L131">        firstSuccess = call.execute();</span>
<span class="nc" id="L132">        responses[attempt] = firstSuccess;</span>
<span class="nc" id="L133">        String cfRay = firstSuccess.header(&quot;CF-RAY&quot;);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (cfRay != null) rays.add(cfRay);</span>

<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (firstSuccess.code() &lt; 500) break; // break loop, got a successful response!</span>

<span class="nc" id="L138">        attempt++;</span>
<span class="nc" id="L139">        LOG.debug(</span>
            &quot;Requesting {} -&gt; {} returned status {}... retrying (attempt {})&quot;,
<span class="nc" id="L141">            apiRequest.getRoute().getMethod(),</span>
            url,
<span class="nc" id="L143">            firstSuccess.code(),</span>
<span class="nc" id="L144">            attempt);</span>
        try {
<span class="nc" id="L146">          Thread.sleep(50 * attempt);</span>
<span class="nc" id="L147">        } catch (InterruptedException ignored) {</span>
<span class="nc" id="L148">        }</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">      } while (attempt &lt; 3 &amp;&amp; firstSuccess.code() &gt;= 500);</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">      if (firstSuccess.code() &gt;= 500) {</span>
        // Epic failure from other end. Attempted 4 times.
<span class="nc" id="L153">        return null;</span>
      }

<span class="nc" id="L156">      retryAfter = rateLimiter.handleResponse(route, firstSuccess);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (!rays.isEmpty()) LOG.debug(&quot;Received response with following cf-rays: {}&quot;, rays);</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (retryAfter == null) apiRequest.handleResponse(new Response(firstSuccess, -1, rays));</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      else if (handleOnRatelimit)</span>
<span class="nc" id="L161">        apiRequest.handleResponse(new Response(firstSuccess, retryAfter, rays));</span>

<span class="nc" id="L163">      return retryAfter;</span>
<span class="nc" id="L164">    } catch (SocketTimeoutException e) {</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">      if (retryOnTimeout &amp;&amp; !retried) return execute(apiRequest, true, handleOnRatelimit);</span>
<span class="nc" id="L166">      LOG.error(&quot;Requester timed out while executing a request&quot;, e);</span>
<span class="nc" id="L167">      apiRequest.handleResponse(new Response(firstSuccess, e, rays));</span>
<span class="nc" id="L168">      return null;</span>
<span class="nc" id="L169">    } catch (Exception e) {</span>
<span class="nc" id="L170">      LOG.error(</span>
          &quot;There was an exception while executing a REST request&quot;,
          e); // This originally only printed on DEBUG in 2.x
<span class="nc" id="L173">      apiRequest.handleResponse(new Response(firstSuccess, e, rays));</span>
<span class="nc" id="L174">      return null;</span>
    } finally {
<span class="nc bnc" id="L176" title="All 2 branches missed.">      for (okhttp3.Response r : responses) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (r == null) break;</span>
<span class="nc" id="L178">        r.close();</span>
      }
    }
  }

  public OkHttpClient getHttpClient() {
<span class="nc" id="L184">    return this.httpClient;</span>
  }

  public void setRetryOnTimeout(boolean retryOnTimeout) {
<span class="nc" id="L188">    this.retryOnTimeout = retryOnTimeout;</span>
<span class="nc" id="L189">  }</span>

  public void shutdown(long time, TimeUnit unit) {
<span class="nc" id="L192">    rateLimiter.shutdown(time, unit);</span>
<span class="nc" id="L193">  }</span>

  public void shutdownNow() {
<span class="nc" id="L196">    rateLimiter.forceShutdown();</span>
<span class="nc" id="L197">  }</span>

  /**
   * Retrieves an {@link java.io.InputStream InputStream} for the provided {@link okhttp3.Response
   * Response}. &lt;br&gt;
   * When the header for {@code content-encoding} is set with {@code gzip} this will wrap the body
   * in a {@link java.util.zip.GZIPInputStream GZIPInputStream} which decodes the data.
   *
   * &lt;p&gt;This is used to make usage of encoded responses more user-friendly in various parts of JDA.
   *
   * @param response The not-null Response object
   * @throws IOException If a GZIP format error has occurred or the compression method used is
   *     unsupported
   * @return InputStream representing the body of this response
   */
  public static InputStream getBody(okhttp3.Response response) throws IOException {
<span class="nc" id="L213">    String encoding = response.header(&quot;content-encoding&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    if (encoding.equals(&quot;gzip&quot;)) return new GZIPInputStream(response.body().byteStream());</span>
<span class="nc" id="L215">    return response.body().byteStream();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>