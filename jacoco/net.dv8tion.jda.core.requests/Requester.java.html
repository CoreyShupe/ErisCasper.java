<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Requester.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.requests</a> &gt; <span class="el_source">Requester.java</span></div><h1>Requester.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.requests;

import java.io.IOException;
import java.io.InputStream;
import java.net.SocketTimeoutException;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;
import net.dv8tion.jda.core.AccountType;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.JDAInfo;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.requests.ratelimit.BotRateLimiter;
import net.dv8tion.jda.core.requests.ratelimit.ClientRateLimiter;
import okhttp3.Call;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.RequestBody;
import okhttp3.internal.http.HttpMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Requester {

<span class="nc" id="L44">  public static final Logger LOG = LoggerFactory.getLogger(Requester.class);</span>

<span class="nc" id="L46">  public static final String DISCORD_API_PREFIX =</span>
<span class="nc" id="L47">      String.format(&quot;https://discordapp.com/api/v%d/&quot;, JDAInfo.DISCORD_REST_VERSION);</span>
<span class="nc" id="L48">  public static final String USER_AGENT =</span>
      &quot;DiscordBot (&quot; + JDAInfo.GITHUB + &quot;, &quot; + JDAInfo.VERSION + &quot;)&quot;;
<span class="nc" id="L50">  public static final MediaType MEDIA_TYPE_JSON =</span>
<span class="nc" id="L51">      MediaType.parse(&quot;application/json; charset=utf-8&quot;);</span>
<span class="nc" id="L52">  public static final RequestBody EMPTY_BODY = RequestBody.create(null, new byte[] {});</span>

  protected final JDAImpl api;
  private final RateLimiter rateLimiter;

  private final OkHttpClient httpClient;

<span class="nc" id="L59">  private volatile boolean retryOnTimeout = false;</span>

  public Requester(JDA api) {
<span class="nc" id="L62">    this(api, api.getAccountType());</span>
<span class="nc" id="L63">  }</span>

<span class="nc" id="L65">  public Requester(JDA api, AccountType accountType) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (accountType == null) throw new NullPointerException(&quot;Provided accountType was null!&quot;);</span>

<span class="nc" id="L68">    this.api = (JDAImpl) api;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (accountType == AccountType.BOT) rateLimiter = new BotRateLimiter(this, 5);</span>
<span class="nc" id="L70">    else rateLimiter = new ClientRateLimiter(this, 5);</span>

<span class="nc" id="L72">    this.httpClient = this.api.getHttpClientBuilder().build();</span>
<span class="nc" id="L73">  }</span>

  public JDAImpl getJDA() {
<span class="nc" id="L76">    return api;</span>
  }

  public &lt;T&gt; void request(Request&lt;T&gt; apiRequest) {
<span class="nc bnc" id="L80" title="All 2 branches missed.">    if (rateLimiter.isShutdown)</span>
<span class="nc" id="L81">      throw new IllegalStateException(</span>
          &quot;The Requester has been shutdown! No new requests can be requested!&quot;);

<span class="nc bnc" id="L84" title="All 2 branches missed.">    if (apiRequest.shouldQueue()) rateLimiter.queueRequest(apiRequest);</span>
<span class="nc" id="L85">    else execute(apiRequest, true);</span>
<span class="nc" id="L86">  }</span>

  public Long execute(Request&lt;?&gt; apiRequest) {
<span class="nc" id="L89">    return execute(apiRequest, false);</span>
  }

  /**
   * Used to execute a Request. Processes request related to provided bucket.
   *
   * @param apiRequest The API request that needs to be sent
   * @param handleOnRateLimit Whether to forward rate-limits, false if rate limit handling should
   *     take over
   * @return Non-null if the request was ratelimited. Returns a Long containing retry_after
   *     milliseconds until the request can be made again. This could either be for the Per-Route
   *     ratelimit or the Global ratelimit. &lt;br&gt;
   *     Check if globalCooldown is {@code null} to determine if it was Per-Route or Global.
   */
  public Long execute(Request&lt;?&gt; apiRequest, boolean handleOnRateLimit) {
<span class="nc" id="L104">    return execute(apiRequest, false, handleOnRateLimit);</span>
  }

  public Long execute(Request&lt;?&gt; apiRequest, boolean retried, boolean handleOnRatelimit) {
<span class="nc" id="L108">    Route.CompiledRoute route = apiRequest.getRoute();</span>
<span class="nc" id="L109">    Long retryAfter = rateLimiter.getRateLimit(route);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    if (retryAfter != null) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      if (handleOnRatelimit)</span>
<span class="nc" id="L112">        apiRequest.handleResponse(new Response(retryAfter, Collections.emptySet()));</span>
<span class="nc" id="L113">      return retryAfter;</span>
    }

<span class="nc" id="L116">    okhttp3.Request.Builder builder = new okhttp3.Request.Builder();</span>

<span class="nc" id="L118">    String url = DISCORD_API_PREFIX + route.getCompiledRoute();</span>
<span class="nc" id="L119">    builder.url(url);</span>

<span class="nc" id="L121">    String method = apiRequest.getRoute().getMethod().toString();</span>
<span class="nc" id="L122">    RequestBody body = apiRequest.getBody();</span>

<span class="nc bnc" id="L124" title="All 4 branches missed.">    if (body == null &amp;&amp; HttpMethod.requiresRequestBody(method)) body = EMPTY_BODY;</span>

<span class="nc" id="L126">    builder.method(method, body).header(&quot;user-agent&quot;, USER_AGENT).header(&quot;accept-encoding&quot;, &quot;gzip&quot;);</span>

    // adding token to all requests to the discord api or cdn pages
    // we can check for startsWith(DISCORD_API_PREFIX) because the cdn endpoints don't need any kind
    // of authorization
<span class="nc bnc" id="L131" title="All 4 branches missed.">    if (url.startsWith(DISCORD_API_PREFIX) &amp;&amp; api.getToken() != null)</span>
<span class="nc" id="L132">      builder.header(&quot;authorization&quot;, api.getToken());</span>

    // Apply custom headers like X-Audit-Log-Reason
    // If customHeaders is null this does nothing
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (apiRequest.getHeaders() != null) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      for (Entry&lt;String, String&gt; header : apiRequest.getHeaders().entrySet())</span>
<span class="nc" id="L138">        builder.addHeader(header.getKey(), header.getValue());</span>
    }

<span class="nc" id="L141">    okhttp3.Request request = builder.build();</span>

<span class="nc" id="L143">    Set&lt;String&gt; rays = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L144">    okhttp3.Response[] responses = new okhttp3.Response[4];</span>
    // we have an array of all responses to later close them all at once
    // the response below this comment is used as the first successful response from the server
<span class="nc" id="L147">    okhttp3.Response firstSuccess = null;</span>
    try {
<span class="nc" id="L149">      int attempt = 0;</span>
      do {
        // If the request has been canceled via the Future, don't execute.
        // if (apiRequest.isCanceled())
        //    return null;
<span class="nc" id="L154">        Call call = httpClient.newCall(request);</span>
<span class="nc" id="L155">        firstSuccess = call.execute();</span>
<span class="nc" id="L156">        responses[attempt] = firstSuccess;</span>
<span class="nc" id="L157">        String cfRay = firstSuccess.header(&quot;CF-RAY&quot;);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (cfRay != null) rays.add(cfRay);</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (firstSuccess.code() &lt; 500) break; // break loop, got a successful response!</span>

<span class="nc" id="L162">        attempt++;</span>
<span class="nc" id="L163">        LOG.debug(</span>
            &quot;Requesting {} -&gt; {} returned status {}... retrying (attempt {})&quot;,
<span class="nc" id="L165">            apiRequest.getRoute().getMethod(),</span>
            url,
<span class="nc" id="L167">            firstSuccess.code(),</span>
<span class="nc" id="L168">            attempt);</span>
        try {
<span class="nc" id="L170">          Thread.sleep(50 * attempt);</span>
<span class="nc" id="L171">        } catch (InterruptedException ignored) {</span>
<span class="nc" id="L172">        }</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">      } while (attempt &lt; 3 &amp;&amp; firstSuccess.code() &gt;= 500);</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">      if (firstSuccess.code() &gt;= 500) {</span>
        // Epic failure from other end. Attempted 4 times.
<span class="nc" id="L177">        return null;</span>
      }

<span class="nc" id="L180">      retryAfter = rateLimiter.handleResponse(route, firstSuccess);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (!rays.isEmpty()) LOG.debug(&quot;Received response with following cf-rays: {}&quot;, rays);</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (retryAfter == null) apiRequest.handleResponse(new Response(firstSuccess, -1, rays));</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      else if (handleOnRatelimit)</span>
<span class="nc" id="L185">        apiRequest.handleResponse(new Response(firstSuccess, retryAfter, rays));</span>

<span class="nc" id="L187">      return retryAfter;</span>
<span class="nc" id="L188">    } catch (SocketTimeoutException e) {</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">      if (retryOnTimeout &amp;&amp; !retried) return execute(apiRequest, true, handleOnRatelimit);</span>
<span class="nc" id="L190">      LOG.error(&quot;Requester timed out while executing a request&quot;, e);</span>
<span class="nc" id="L191">      apiRequest.handleResponse(new Response(firstSuccess, e, rays));</span>
<span class="nc" id="L192">      return null;</span>
<span class="nc" id="L193">    } catch (Exception e) {</span>
<span class="nc" id="L194">      LOG.error(</span>
          &quot;There was an exception while executing a REST request&quot;,
          e); // This originally only printed on DEBUG in 2.x
<span class="nc" id="L197">      apiRequest.handleResponse(new Response(firstSuccess, e, rays));</span>
<span class="nc" id="L198">      return null;</span>
    } finally {
<span class="nc bnc" id="L200" title="All 2 branches missed.">      for (okhttp3.Response r : responses) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (r == null) break;</span>
<span class="nc" id="L202">        r.close();</span>
      }
    }
  }

  public OkHttpClient getHttpClient() {
<span class="nc" id="L208">    return this.httpClient;</span>
  }

  public RateLimiter getRateLimiter() {
<span class="nc" id="L212">    return rateLimiter;</span>
  }

  public void setRetryOnTimeout(boolean retryOnTimeout) {
<span class="nc" id="L216">    this.retryOnTimeout = retryOnTimeout;</span>
<span class="nc" id="L217">  }</span>

  public void shutdown(long time, TimeUnit unit) {
<span class="nc" id="L220">    rateLimiter.shutdown(time, unit);</span>
<span class="nc" id="L221">  }</span>

  public void shutdownNow() {
<span class="nc" id="L224">    rateLimiter.forceShutdown();</span>
<span class="nc" id="L225">  }</span>

  /**
   * Retrieves an {@link java.io.InputStream InputStream} for the provided {@link okhttp3.Response
   * Response}. &lt;br&gt;
   * When the header for {@code content-encoding} is set with {@code gzip} this will wrap the body
   * in a {@link java.util.zip.GZIPInputStream GZIPInputStream} which decodes the data.
   *
   * &lt;p&gt;This is used to make usage of encoded responses more user-friendly in various parts of JDA.
   *
   * @param response The not-null Response object
   * @throws IOException If a GZIP format error has occurred or the compression method used is
   *     unsupported
   * @return InputStream representing the body of this response
   */
  public static InputStream getBody(okhttp3.Response response) throws IOException {
<span class="nc" id="L241">    String encoding = response.header(&quot;content-encoding&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (encoding.equals(&quot;gzip&quot;)) return new GZIPInputStream(response.body().byteStream());</span>
<span class="nc" id="L243">    return response.body().byteStream();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>