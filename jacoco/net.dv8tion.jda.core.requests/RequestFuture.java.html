<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestFuture.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.requests</a> &gt; <span class="el_source">RequestFuture.java</span></div><h1>RequestFuture.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.requests;

import java.util.Collection;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Future;
import java.util.stream.Stream;
import net.dv8tion.jda.core.utils.Checks;

/**
 * Future allowing for use of continuations.
 *
 * @param &lt;T&gt; The completion type for this Future
 */
public interface RequestFuture&lt;T&gt; extends Future&lt;T&gt;, CompletionStage&lt;T&gt; {
  /**
   * Returns a new CompletableFuture that is completed when all of the given RequestFutures
   * complete. If any of the given RequestFutures complete exceptionally, then the returned
   * CompletableFuture also does so, with a CompletionException holding this exception as its cause.
   * Otherwise, the results, if any, of the given RequestFutures are not reflected in the returned
   * CompletableFuture, but may be obtained by inspecting them individually. If no RequestFutures
   * are provided, returns a CompletableFuture completed with the value {@code null}.
   *
   * &lt;p&gt;Among the applications of this method is to await completion of a set of independent
   * RequestFutures before continuing a program, as in: {@code RequestFuture.allOf(c1, c2,
   * c3).join();}.
   *
   * @param cfs the RequestFutures
   * @throws java.lang.IllegalArgumentException if the array or any of its elements are {@code null}
   * @return a new CompletableFuture that is completed when all of the given RequestFutures complete
   * @see java.util.concurrent.CompletableFuture#allOf(java.util.concurrent.CompletableFuture[])
   *     CompletableFuture.allOf(...)
   */
  static CompletableFuture&lt;Void&gt; allOf(RequestFuture&lt;?&gt;... cfs) {
<span class="nc" id="L51">    Checks.noneNull(cfs, &quot;RequestFutures&quot;);</span>
<span class="nc" id="L52">    CompletableFuture[] all =</span>
<span class="nc" id="L53">        Stream.of(cfs).map(CompletableFuture.class::cast).toArray(CompletableFuture[]::new);</span>
<span class="nc" id="L54">    return CompletableFuture.allOf(all);</span>
  }

  /**
   * Returns a new CompletableFuture that is completed when all of the given Futures complete. If
   * any of the given Futures complete exceptionally, then the returned CompletableFuture also does
   * so, with a CompletionException holding this exception as its cause. Otherwise, the results, if
   * any, of the given RequestFutures are not reflected in the returned CompletableFuture, but may
   * be obtained by inspecting them individually. If no Futures are provided, returns a
   * CompletableFuture completed with the value {@code null}.
   *
   * &lt;p&gt;Among the applications of this method is to await completion of a set of independent
   * RequestFutures before continuing a program, as in: {@code RequestFuture.allOf(c1, c2,
   * c3).join();}.
   *
   * @param  &lt;F&gt; the future implementation
   * @param cfs the Futures
   * @throws java.lang.IllegalArgumentException if the collection or any of its elements are {@code
   *     null}
   * @return a new CompletableFuture that is completed when all of the given Futures complete
   * @see java.util.concurrent.CompletableFuture#allOf(java.util.concurrent.CompletableFuture[])
   *     CompletableFuture.allOf(...)
   */
  static &lt;F extends Future&lt;?&gt; &amp; CompletionStage&lt;?&gt;&gt; CompletableFuture&lt;Void&gt; allOf(
      Collection&lt;F&gt; cfs) {
<span class="nc" id="L79">    Checks.notNull(cfs, &quot;Collection&quot;);</span>
<span class="nc" id="L80">    CompletableFuture[] all =</span>
<span class="nc" id="L81">        cfs.stream().map(CompletableFuture.class::cast).toArray(CompletableFuture[]::new);</span>
<span class="nc" id="L82">    return CompletableFuture.allOf(all);</span>
  }

  /**
   * Returns a new CompletableFuture that is completed when any of the given RequestFutures
   * complete, with the same result. Otherwise, if it completed exceptionally, the returned
   * CompletableFuture also does so, with a CompletionException holding this exception as its cause.
   * If no RequestFutures are provided, returns an incomplete CompletableFuture.
   *
   * @param cfs the RequestFutures
   * @throws java.lang.IllegalArgumentException if the array or any of its elements are {@code null}
   * @return a new CompletableFuture that is completed with the result or exception of any of the
   *     given RequestFutures when one completes
   * @see java.util.concurrent.CompletableFuture#anyOf(java.util.concurrent.CompletableFuture[])
   *     CompletableFuture.anyOf(...)
   */
  static CompletableFuture&lt;Object&gt; anyOf(RequestFuture&lt;?&gt;... cfs) {
<span class="nc" id="L99">    Checks.noneNull(cfs, &quot;RequestFutures&quot;);</span>
<span class="nc" id="L100">    CompletableFuture[] all =</span>
<span class="nc" id="L101">        Stream.of(cfs).map(CompletableFuture.class::cast).toArray(CompletableFuture[]::new);</span>
<span class="nc" id="L102">    return CompletableFuture.anyOf(all);</span>
  }

  /**
   * Returns a new CompletableFuture that is completed when any of the given Futures complete, with
   * the same result. Otherwise, if it completed exceptionally, the returned CompletableFuture also
   * does so, with a CompletionException holding this exception as its cause. If no Futures are
   * provided, returns an incomplete CompletableFuture.
   *
   * @param  &lt;F&gt; the future implementation
   * @param cfs the Futures
   * @throws java.lang.IllegalArgumentException if the collection or any of its elements are {@code
   *     null}
   * @return a new CompletableFuture that is completed with the result or exception of any of the
   *     given Futures when one completes
   * @see java.util.concurrent.CompletableFuture#anyOf(java.util.concurrent.CompletableFuture[])
   *     CompletableFuture.anyOf(...)
   */
  static &lt;F extends Future&lt;?&gt; &amp; CompletionStage&lt;?&gt;&gt; CompletableFuture&lt;Object&gt; anyOf(
      Collection&lt;F&gt; cfs) {
<span class="nc" id="L122">    Checks.notNull(cfs, &quot;Collection&quot;);</span>
<span class="nc" id="L123">    CompletableFuture[] all =</span>
<span class="nc" id="L124">        cfs.stream().map(CompletableFuture.class::cast).toArray(CompletableFuture[]::new);</span>
<span class="nc" id="L125">    return CompletableFuture.anyOf(all);</span>
  }

  /* Expose harmless functionality */

  /**
   * Returns the result value when complete, or throws an (unchecked) exception if completed
   * exceptionally. To better conform with the use of common functional forms, if a computation
   * involved in the completion of this CompletableFuture threw an exception, this method throws an
   * (unchecked) {@link java.util.concurrent.CompletionException} with the underlying exception as
   * its cause.
   *
   * @throws java.util.concurrent.CancellationException if the computation was cancelled
   * @throws java.util.concurrent.CompletionException if this future completed exceptionally or a
   *     completion computation threw an exception
   * @return the result value
   */
  T join();

  /**
   * Returns the result value (or throws any encountered exception) if completed, else returns the
   * given valueIfAbsent.
   *
   * @param valueIfAbsent the value to return if not completed
   * @throws java.util.concurrent.CancellationException if the computation was cancelled
   * @throws java.util.concurrent.CompletionException if this future completed exceptionally or a
   *     completion computation threw an exception
   * @return the result value, if completed, else the given valueIfAbsent
   */
  T getNow(T valueIfAbsent);

  /**
   * Returns {@code true} if this RequestFuture completed exceptionally, in any way. Possible causes
   * include cancellation, explicit invocation of {@code completeExceptionally}, and abrupt
   * termination of a CompletionStage action.
   *
   * @return {@code true} if this RequestFuture completed exceptionally
   */
  boolean isCompletedExceptionally();

  /**
   * Returns the estimated number of RequestFutures whose completions are awaiting completion of
   * this RequestFuture. This method is designed for use in monitoring system state, not for
   * synchronization control.
   *
   * @return the number of dependent RequestFutures
   */
  int getNumberOfDependents();

  /*
      Hide harmful functionality

      - complete
      - completeExceptionally
      - obtrudeValue
      - obtrudeException
  */

  /**
   * &lt;b&gt;This method is unsupported by the current implementation!&lt;/b&gt;
   *
   * &lt;p&gt;{@inheritDoc}
   */
  @Override
  CompletableFuture&lt;T&gt; toCompletableFuture();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>