<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PaginationAction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.requests.restaction.pagination</a> &gt; <span class="el_source">PaginationAction.java</span></div><h1>PaginationAction.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spieß
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.requests.restaction.pagination;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.requests.Request;
import net.dv8tion.jda.core.requests.Response;
import net.dv8tion.jda.core.requests.RestAction;
import net.dv8tion.jda.core.requests.Route;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.Procedure;

/**
 * {@link net.dv8tion.jda.core.requests.RestAction RestAction} specification used to retrieve
 * entities for paginated endpoints (before, after, limit).
 *
 * &lt;p&gt;&lt;b&gt;Examples&lt;/b&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 * /**
 *   * Retrieves messages until the specified limit is reached. The messages will be limited after being filtered by the user.
 *   * If the user hasn't sent enough messages this will go through all messages so it is recommended to add an additional end condition.
 *   *&amp;#47;
 * public static{@literal List&lt;Message&gt;} getMessagesByUser(MessageChannel channel, User user, int limit)
 * {
 *     &lt;u&gt;MessagePaginationAction&lt;/u&gt; action = channel.&lt;u&gt;getIterableHistory&lt;/u&gt;();
 *     Stream{@literal &lt;Message&gt;} messageStream = action.stream()
 *             .limit(limit * 2) // used to limit amount of messages to check, if user hasn't sent enough messages it would go on forever
 *             .filter( message{@literal -&gt;} message.getAuthor().equals(user) )
 *             .limit(limit); // limit on filtered stream will be checked independently from previous limit
 *     return messageStream.collect(Collectors.toList());
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 * /**
 *  * Iterates messages in an async stream and stops once the limit has been reached.
 *  *&amp;#47;
 * public static void onEachMessageAsync(MessageChannel channel, {@literal Consumer&lt;Message&gt;} consumer, int limit)
 * {
 *     if (limit{@literal &lt;} 1)
 *         return;
 *     &lt;u&gt;MessagePaginationAction&lt;/u&gt; action = channel.&lt;u&gt;getIterableHistory&lt;/u&gt;();
 *     AtomicInteger counter = new AtomicInteger(limit);
 *     action.forEachAsync( (message){@literal -&gt;}
 *     {
 *         consumer.accept(message);
 *         // if false the iteration is terminated; else it continues
 *         return counter.decrementAndGet() == 0;
 *     });
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param  &lt;M&gt; The current implementation used as chaining return value
 * @param  &lt;T&gt; The type of entity to paginate
 * @since 3.1
 * @author Florian Spieß
 */
public abstract class PaginationAction&lt;T, M extends PaginationAction&lt;T, M&gt;&gt;
    extends RestAction&lt;List&lt;T&gt;&gt; implements Iterable&lt;T&gt; {
<span class="nc" id="L84">  protected final List&lt;T&gt; cached = new CopyOnWriteArrayList&lt;&gt;();</span>
  protected final int maxLimit;
  protected final int minLimit;
  protected final AtomicInteger limit;

<span class="nc" id="L89">  protected volatile T last = null;</span>
<span class="nc" id="L90">  protected volatile boolean useCache = true;</span>

  /**
   * Creates a new PaginationAction instance
   *
   * @param api The current JDA instance
   * @param route The base route
   * @param maxLimit The inclusive maximum limit that can be used in {@link #limit(int)}
   * @param minLimit The inclusive minimum limit that can be used in {@link #limit(int)}
   * @param initialLimit The initial limit to use on the pagination endpoint
   */
  public PaginationAction(
      JDA api, Route.CompiledRoute route, int minLimit, int maxLimit, int initialLimit) {
<span class="nc" id="L103">    super(api, route);</span>
<span class="nc" id="L104">    this.maxLimit = maxLimit;</span>
<span class="nc" id="L105">    this.minLimit = minLimit;</span>
<span class="nc" id="L106">    this.limit = new AtomicInteger(initialLimit);</span>
<span class="nc" id="L107">  }</span>

  /**
   * Creates a new PaginationAction instance &lt;br&gt;
   * This is used for PaginationActions that should not deal with {@link #limit(int)}
   *
   * @param api The current JDA instance
   */
  public PaginationAction(JDA api) {
<span class="nc" id="L116">    super(api, null);</span>
<span class="nc" id="L117">    this.maxLimit = 0;</span>
<span class="nc" id="L118">    this.minLimit = 0;</span>
<span class="nc" id="L119">    this.limit = new AtomicInteger(0);</span>
<span class="nc" id="L120">  }</span>

  @Override
  public M setCheck(BooleanSupplier checks) {
<span class="nc" id="L124">    return (M) super.setCheck(checks);</span>
  }

  /**
   * The current amount of cached entities for this PaginationAction
   *
   * @return int size of currently cached entities
   */
  public int cacheSize() {
<span class="nc" id="L133">    return cached.size();</span>
  }

  /**
   * Whether the cache of this PaginationAction is empty. &lt;br&gt;
   * Logically equivalent to {@code cacheSize() == 0}.
   *
   * @return True, if no entities have been retrieved yet.
   */
  public boolean isEmpty() {
<span class="nc" id="L143">    return cached.isEmpty();</span>
  }

  /**
   * The currently cached entities of recent execution tasks. &lt;br&gt;
   * Every {@link net.dv8tion.jda.core.requests.RestAction RestAction} success adds to this List.
   * (Thread-Safe due to {@link java.util.concurrent.CopyOnWriteArrayList CopyOnWriteArrayList})
   *
   * &lt;p&gt;&lt;b&gt;This &lt;u&gt;does not&lt;/u&gt; contain all entities for the paginated endpoint unless the
   * pagination has reached an end!&lt;/b&gt; &lt;br&gt;
   * It only contains those entities which already have been retrieved.
   *
   * @return Immutable {@link java.util.List List} containing all currently cached entities for this
   *     PaginationAction
   */
  public List&lt;T&gt; getCached() {
<span class="nc" id="L159">    return Collections.unmodifiableList(cached);</span>
  }

  /**
   * The most recent entity retrieved by this PaginationAction instance
   *
   * @throws java.util.NoSuchElementException If no entities have been retrieved yet (see {@link
   *     #isEmpty()})
   * @return The most recent cached entity
   */
  public T getLast() {
<span class="nc" id="L170">    final T last = this.last;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (last == null) throw new NoSuchElementException(&quot;No entities have been retrieved yet.&quot;);</span>
<span class="nc" id="L172">    return last;</span>
  }

  /**
   * The first cached entity retrieved by this PaginationAction instance
   *
   * @throws java.util.NoSuchElementException If no entities have been retrieved yet (see {@link
   *     #isEmpty()})
   * @return The very first cached entity
   */
  public T getFirst() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (cached.isEmpty()) throw new NoSuchElementException(&quot;No entities have been retrieved yet.&quot;);</span>
<span class="nc" id="L184">    return cached.get(0);</span>
  }

  /**
   * Sets the limit that should be used in the next RestAction completion call.
   *
   * &lt;p&gt;The specified limit may not be below the {@link #getMinLimit() Minimum Limit} nor above the
   * {@link #getMaxLimit() Maximum Limit}. Unless these limits are specifically omitted. (See
   * documentation of methods)
   *
   * &lt;p&gt;&lt;b&gt;This limit represents how many entities will be retrieved per request and &lt;u&gt;NOT&lt;/u&gt; the
   * maximum amount of entities that should be retrieved for iteration/sequencing.&lt;/b&gt; &lt;br&gt;
   * {@code action.limit(50).complete()} &lt;br&gt;
   * is not the same as &lt;br&gt;
   * {@code action.stream().limit(50).collect(collector)}
   *
   * @param limit The limit to use
   * @throws java.lang.IllegalArgumentException If the provided limit is out of range
   * @return The current PaginationAction implementation instance
   */
  public M limit(final int limit) {
<span class="nc bnc" id="L205" title="All 4 branches missed.">    Checks.check(maxLimit == 0 || limit &lt;= maxLimit, &quot;Limit must not exceed %d!&quot;, maxLimit);</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">    Checks.check(</span>
<span class="nc" id="L207">        minLimit == 0 || limit &gt;= minLimit, &quot;Limit must be greater or equal to %d&quot;, minLimit);</span>

<span class="nc" id="L209">    synchronized (this.limit) {</span>
<span class="nc" id="L210">      this.limit.set(limit);</span>
<span class="nc" id="L211">    }</span>
<span class="nc" id="L212">    return (M) this;</span>
  }

  /**
   * Whether already retrieved entities should be stored within the internal cache. All cached
   * entities will be available from {@link #getCached()}. &lt;b&gt;Default: true&lt;/b&gt; &lt;br&gt;
   * This being disabled allows unused entities to be removed from the memory heap by the garbage
   * collector. If this is enabled this will not take place until all references to this
   * PaginationAction have been cleared.
   *
   * @param enableCache Whether to enable entity cache
   * @return The current PaginationAction implementation instance
   */
  public M cache(final boolean enableCache) {
<span class="nc" id="L226">    this.useCache = enableCache;</span>
<span class="nc" id="L227">    return (M) this;</span>
  }

  /**
   * Whether retrieved entities are stored within an internal cache. If this is {@code false}
   * entities retrieved by the iterator or a call to a {@link
   * net.dv8tion.jda.core.requests.RestAction RestAction} terminal operation will not be retrievable
   * from {@link #getCached()}. &lt;br&gt;
   * This being disabled allows unused entities to be removed from the memory heap by the garbage
   * collector. If this is enabled this will not take place until all references to this
   * PaginationAction have been cleared.
   *
   * @return True, If entities will be cached.
   */
  public boolean isCacheEnabled() {
<span class="nc" id="L242">    return useCache;</span>
  }

  /**
   * The maximum limit that can be used for this PaginationAction &lt;br&gt;
   * Limits provided to {@link #limit(int)} must not be greater than the returned value. &lt;br&gt;
   * If no maximum limit is used this will return {@code 0}. That means there is no upper border for
   * limiting this PaginationAction
   *
   * @return The maximum limit
   */
  public final int getMaxLimit() {
<span class="nc" id="L254">    return maxLimit;</span>
  }

  /**
   * The minimum limit that can be used for this PaginationAction &lt;br&gt;
   * Limits provided to {@link #limit(int)} must not be less than the returned value. &lt;br&gt;
   * If no minimum limit is used this will return {@code 0}. That means there is no lower border for
   * limiting this PaginationAction
   *
   * @return The minimum limit
   */
  public final int getMinLimit() {
<span class="nc" id="L266">    return minLimit;</span>
  }

  /**
   * The currently used limit. &lt;br&gt;
   * If this PaginationAction does not use limitation this will return {@code 0}
   *
   * @return limit
   */
  public final int getLimit() {
<span class="nc" id="L276">    return limit.get();</span>
  }

  /**
   * {@link net.dv8tion.jda.core.requests.restaction.pagination.PaginationAction.PaginationIterator
   * PaginationIterator} that will iterate over all entities for this PaginationAction.
   *
   * @return new PaginationIterator
   */
  @Override
  public PaginationIterator iterator() {
<span class="nc" id="L287">    return new PaginationIterator();</span>
  }

  /**
   * Iterates over all entities until the provided action returns {@code false}! &lt;br&gt;
   * This operation is different from {@link #forEach(Consumer)} as it uses successive {@link
   * #queue()} tasks to iterate each entity in callback threads instead of the calling active
   * thread. This means that this method fully works on different threads to retrieve new entities.
   *
   * &lt;p&gt;&lt;b&gt;This iteration will include already cached entities, in order to exclude cached entities
   * use {@link #forEachRemainingAsync(Procedure)}&lt;/b&gt;
   *
   * &lt;h1&gt;Example&lt;/h1&gt;
   *
   * &lt;pre&gt;{@code
   * //deletes messages until it finds a user that is still in guild
   * public void cleanupMessages(MessagePaginationAction action)
   * {
   *     action.forEachAsync( (message) -&gt;
   *     {
   *         Guild guild = message.getGuild();
   *         if (!guild.isMember(message.getAuthor()))
   *             message.delete().queue();
   *         else
   *             return false;
   *         return true;
   *     });
   * }
   * }&lt;/pre&gt;
   *
   * @param action {@link net.dv8tion.jda.core.utils.Procedure Procedure} returning {@code true} if
   *     iteration should continue!
   * @throws java.lang.IllegalArgumentException If the provided Procedure is {@code null}
   * @return {@link java.util.concurrent.Future Future} that can be cancelled to stop iteration from
   *     outside!
   */
  public Future&lt;?&gt; forEachAsync(final Procedure&lt;T&gt; action) {
<span class="nc" id="L324">    return forEachAsync(</span>
        action,
        (throwable) -&gt; {
<span class="nc bnc" id="L327" title="All 2 branches missed.">          if (RestAction.DEFAULT_FAILURE != null) RestAction.DEFAULT_FAILURE.accept(throwable);</span>
<span class="nc" id="L328">        });</span>
  }

  /**
   * Iterates over all entities until the provided action returns {@code false}! &lt;br&gt;
   * This operation is different from {@link #forEach(Consumer)} as it uses successive {@link
   * #queue()} tasks to iterate each entity in callback threads instead of the calling active
   * thread. This means that this method fully works on different threads to retrieve new entities.
   *
   * &lt;p&gt;&lt;b&gt;This iteration will include already cached entities, in order to exclude cached entities
   * use {@link #forEachRemainingAsync(Procedure, Consumer)}&lt;/b&gt;
   *
   * &lt;h1&gt;Example&lt;/h1&gt;
   *
   * &lt;pre&gt;{@code
   * //deletes messages until it finds a user that is still in guild
   * public void cleanupMessages(MessagePaginationAction action)
   * {
   *     action.forEachAsync( (message) -&gt;
   *     {
   *         Guild guild = message.getGuild();
   *         if (!guild.isMember(message.getAuthor()))
   *             message.delete().queue();
   *         else
   *             return false;
   *         return true;
   *     }, Throwable::printStackTrace);
   * }
   * }&lt;/pre&gt;
   *
   * @param action {@link net.dv8tion.jda.core.utils.Procedure Procedure} returning {@code true} if
   *     iteration should continue!
   * @param failure {@link java.util.function.Consumer Consumer} that should handle any throwables
   *     from the action
   * @throws java.lang.IllegalArgumentException If the provided Procedure or the failure Consumer is
   *     {@code null}
   * @return {@link java.util.concurrent.Future Future} that can be cancelled to stop iteration from
   *     outside!
   */
  public Future&lt;?&gt; forEachAsync(final Procedure&lt;T&gt; action, final Consumer&lt;Throwable&gt; failure) {
<span class="nc" id="L368">    Checks.notNull(action, &quot;Procedure&quot;);</span>
<span class="nc" id="L369">    Checks.notNull(failure, &quot;Failure Consumer&quot;);</span>

<span class="nc" id="L371">    final CompletableFuture&lt;?&gt; task = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L372">    final Consumer&lt;List&lt;T&gt;&gt; acceptor =</span>
        new ChainedConsumer(
            task,
            action,
            (throwable) -&gt; {
<span class="nc" id="L377">              task.completeExceptionally(throwable);</span>
<span class="nc" id="L378">              failure.accept(throwable);</span>
<span class="nc" id="L379">            });</span>
    try {
<span class="nc" id="L381">      acceptor.accept(cached);</span>
<span class="nc" id="L382">    } catch (Exception ex) {</span>
<span class="nc" id="L383">      failure.accept(ex);</span>
<span class="nc" id="L384">      task.completeExceptionally(ex);</span>
<span class="nc" id="L385">    }</span>
<span class="nc" id="L386">    return task;</span>
  }

  /**
   * Iterates over all remaining entities until the provided action returns {@code false}! &lt;br&gt;
   * This operation is different from {@link #forEachRemaining(Procedure)} as it uses successive
   * {@link #queue()} tasks to iterate each entity in callback threads instead of the calling active
   * thread. This means that this method fully works on different threads to retrieve new entities.
   *
   * &lt;p&gt;&lt;b&gt;This iteration will exclude already cached entities, in order to include cached entities
   * use {@link #forEachAsync(Procedure)}&lt;/b&gt;
   *
   * &lt;h1&gt;Example&lt;/h1&gt;
   *
   * &lt;pre&gt;{@code
   * //deletes messages until it finds a user that is still in guild
   * public void cleanupMessages(MessagePaginationAction action)
   * {
   *     action.forEachRemainingAsync( (message) -&gt;
   *     {
   *         Guild guild = message.getGuild();
   *         if (!guild.isMember(message.getAuthor()))
   *             message.delete().queue();
   *         else
   *             return false;
   *         return true;
   *     });
   * }
   * }&lt;/pre&gt;
   *
   * @param action {@link net.dv8tion.jda.core.utils.Procedure Procedure} returning {@code true} if
   *     iteration should continue!
   * @throws java.lang.IllegalArgumentException If the provided Procedure is {@code null}
   * @return {@link java.util.concurrent.Future Future} that can be cancelled to stop iteration from
   *     outside!
   */
  public Future&lt;?&gt; forEachRemainingAsync(final Procedure&lt;T&gt; action) {
<span class="nc" id="L423">    return forEachRemainingAsync(</span>
        action,
        (throwable) -&gt; {
<span class="nc bnc" id="L426" title="All 2 branches missed.">          if (RestAction.DEFAULT_FAILURE != null) RestAction.DEFAULT_FAILURE.accept(throwable);</span>
<span class="nc" id="L427">        });</span>
  }

  /**
   * Iterates over all remaining entities until the provided action returns {@code false}! &lt;br&gt;
   * This operation is different from {@link #forEachRemaining(Procedure)} as it uses successive
   * {@link #queue()} tasks to iterate each entity in callback threads instead of the calling active
   * thread. This means that this method fully works on different threads to retrieve new entities.
   *
   * &lt;p&gt;&lt;b&gt;This iteration will exclude already cached entities, in order to include cached entities
   * use {@link #forEachAsync(Procedure, Consumer)}&lt;/b&gt;
   *
   * &lt;h1&gt;Example&lt;/h1&gt;
   *
   * &lt;pre&gt;{@code
   * //deletes messages until it finds a user that is still in guild
   * public void cleanupMessages(MessagePaginationAction action)
   * {
   *     action.forEachRemainingAsync( (message) -&gt;
   *     {
   *         Guild guild = message.getGuild();
   *         if (!guild.isMember(message.getAuthor()))
   *             message.delete().queue();
   *         else
   *             return false;
   *         return true;
   *     }, Throwable::printStackTrace);
   * }
   * }&lt;/pre&gt;
   *
   * @param action {@link net.dv8tion.jda.core.utils.Procedure Procedure} returning {@code true} if
   *     iteration should continue!
   * @param failure {@link java.util.function.Consumer Consumer} that should handle any throwables
   *     from the action
   * @throws java.lang.IllegalArgumentException If the provided Procedure or the failure Consumer is
   *     {@code null}
   * @return {@link java.util.concurrent.Future Future} that can be cancelled to stop iteration from
   *     outside!
   */
  public Future&lt;?&gt; forEachRemainingAsync(
      final Procedure&lt;T&gt; action, final Consumer&lt;Throwable&gt; failure) {
<span class="nc" id="L468">    Checks.notNull(action, &quot;Procedure&quot;);</span>
<span class="nc" id="L469">    Checks.notNull(failure, &quot;Failure Consumer&quot;);</span>

<span class="nc" id="L471">    final CompletableFuture&lt;?&gt; task = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L472">    final Consumer&lt;List&lt;T&gt;&gt; acceptor =</span>
        new ChainedConsumer(
            task,
            action,
            (throwable) -&gt; {
<span class="nc" id="L477">              task.completeExceptionally(throwable);</span>
<span class="nc" id="L478">              failure.accept(throwable);</span>
<span class="nc" id="L479">            });</span>
    try {
      // not starting with cache here unlike forEachAsync
<span class="nc" id="L482">      acceptor.accept(Collections.emptyList());</span>
<span class="nc" id="L483">    } catch (Exception ex) {</span>
<span class="nc" id="L484">      failure.accept(ex);</span>
<span class="nc" id="L485">      task.completeExceptionally(ex);</span>
<span class="nc" id="L486">    }</span>
<span class="nc" id="L487">    return task;</span>
  }

  /**
   * Iterates over all remaining entities until the provided action returns {@code false}! &lt;br&gt;
   * Skipping past already cached entities to iterate all remaining entities of this
   * PaginationAction.
   *
   * &lt;p&gt;&lt;b&gt;This is a blocking operation that might take a while to complete&lt;/b&gt;
   *
   * @param action The {@link net.dv8tion.jda.core.utils.Procedure Procedure} which should return
   *     {@code true} to continue iterating
   */
  public void forEachRemaining(final Procedure&lt;T&gt; action) {
<span class="nc" id="L501">    Checks.notNull(action, &quot;Procedure&quot;);</span>
<span class="nc" id="L502">    Queue&lt;T&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">    while (queue.addAll(getNextChunk())) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">      while (!queue.isEmpty()) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (!action.execute(queue.poll())) return;</span>
      }
    }
<span class="nc" id="L508">  }</span>

  @Override
  public Spliterator&lt;T&gt; spliterator() {
<span class="nc" id="L512">    return Spliterators.spliteratorUnknownSize(iterator(), Spliterator.IMMUTABLE);</span>
  }

  /**
   * A sequential {@link java.util.stream.Stream Stream} with this PaginationAction as its source.
   *
   * @return a sequential {@code Stream} over the elements in this PaginationAction
   */
  public Stream&lt;T&gt; stream() {
<span class="nc" id="L521">    return StreamSupport.stream(spliterator(), false);</span>
  }

  /**
   * Returns a possibly parallel {@link java.util.stream.Stream Stream} with this PaginationAction
   * as its source. It is allowable for this method to return a sequential stream.
   *
   * @return a sequential {@code Stream} over the elements in this PaginationAction
   */
  public Stream&lt;T&gt; parallelStream() {
<span class="nc" id="L531">    return StreamSupport.stream(spliterator(), true);</span>
  }

  protected abstract void handleResponse(Response response, Request&lt;List&lt;T&gt;&gt; request);

  private List&lt;T&gt; getNextChunk() {
    List&lt;T&gt; items;
<span class="nc" id="L538">    synchronized (limit) {</span>
<span class="nc" id="L539">      final int current = limit.getAndSet(getMaxLimit());</span>
<span class="nc" id="L540">      items = complete();</span>
<span class="nc" id="L541">      limit.set(current);</span>
<span class="nc" id="L542">    }</span>
<span class="nc" id="L543">    return items;</span>
  }

  /**
   * Iterator implementation for a {@link
   * net.dv8tion.jda.core.requests.restaction.pagination.PaginationAction PaginationAction}. &lt;br&gt;
   * This iterator will first iterate over all currently cached entities and continue to retrieve
   * new entities as needed.
   *
   * &lt;p&gt;To retrieve new entities after reaching the end of the current cache, this iterator will
   * request a List of new entities through a call of {@link
   * net.dv8tion.jda.core.requests.RestAction#complete() RestAction.complete()}. &lt;br&gt;
   * &lt;b&gt;It is recommended to use the highest possible limit for this task. (see {@link
   * #limit(int)})&lt;/b&gt;
   */
<span class="nc" id="L558">  public class PaginationIterator implements Iterator&lt;T&gt; {</span>
<span class="nc" id="L559">    protected Queue&lt;T&gt; items = new LinkedList&lt;&gt;(cached);</span>

    @Override
    public boolean hasNext() {
<span class="nc bnc" id="L563" title="All 2 branches missed.">      if (items == null) return false;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">      if (!hitEnd()) return true;</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">      if (items.addAll(getNextChunk())) return true;</span>

      // null indicates that the real end has been reached
<span class="nc" id="L569">      items = null;</span>
<span class="nc" id="L570">      return false;</span>
    }

    @Override
    public T next() {
<span class="nc bnc" id="L575" title="All 2 branches missed.">      if (!hasNext()) throw new NoSuchElementException(&quot;Reached End of pagination task!&quot;);</span>
<span class="nc" id="L576">      return items.poll();</span>
    }

    protected boolean hitEnd() {
<span class="nc" id="L580">      return items.isEmpty();</span>
    }
  }

  protected class ChainedConsumer implements Consumer&lt;List&lt;T&gt;&gt; {
    protected final CompletableFuture&lt;?&gt; task;
    protected final Procedure&lt;T&gt; action;
    protected final Consumer&lt;Throwable&gt; throwableConsumer;
<span class="nc" id="L588">    protected boolean initial = true;</span>

    protected ChainedConsumer(
        final CompletableFuture&lt;?&gt; task,
        final Procedure&lt;T&gt; action,
<span class="nc" id="L593">        final Consumer&lt;Throwable&gt; throwableConsumer) {</span>
<span class="nc" id="L594">      this.task = task;</span>
<span class="nc" id="L595">      this.action = action;</span>
<span class="nc" id="L596">      this.throwableConsumer = throwableConsumer;</span>
<span class="nc" id="L597">    }</span>

    @Override
    public void accept(final List&lt;T&gt; list) {
<span class="nc bnc" id="L601" title="All 4 branches missed.">      if (list.isEmpty() &amp;&amp; !initial) {</span>
<span class="nc" id="L602">        task.complete(null);</span>
<span class="nc" id="L603">        return;</span>
      }
<span class="nc" id="L605">      initial = false;</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">      for (T it : list) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (task.isCancelled()) return;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (action.execute(it)) continue;</span>
<span class="nc" id="L610">        task.complete(null);</span>
<span class="nc" id="L611">        return;</span>
      }
<span class="nc" id="L613">      synchronized (limit) {</span>
<span class="nc" id="L614">        final int currentLimit = limit.getAndSet(maxLimit);</span>
<span class="nc" id="L615">        queue(this, throwableConsumer);</span>
<span class="nc" id="L616">        limit.set(currentLimit);</span>
<span class="nc" id="L617">      }</span>
<span class="nc" id="L618">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>