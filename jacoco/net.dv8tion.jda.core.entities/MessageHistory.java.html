<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageHistory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core.entities</a> &gt; <span class="el_source">MessageHistory.java</span></div><h1>MessageHistory.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core.entities;

import java.util.*;
import net.dv8tion.jda.core.JDA;
import net.dv8tion.jda.core.Permission;
import net.dv8tion.jda.core.exceptions.InsufficientPermissionException;
import net.dv8tion.jda.core.requests.Request;
import net.dv8tion.jda.core.requests.Response;
import net.dv8tion.jda.core.requests.RestAction;
import net.dv8tion.jda.core.requests.Route;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.MiscUtil;
import org.apache.commons.collections4.map.ListOrderedMap;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * Represents an access point to the {@link net.dv8tion.jda.core.entities.Message Message} history
 * of a {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel}. &lt;br&gt;
 * &lt;b&gt;Note:&lt;/b&gt; Message order is always in recent to past order. I.e: A message at index 0 of a list
 * is more recent than a message at index 1.
 */
public class MessageHistory {
  protected final MessageChannel channel;

<span class="nc" id="L43">  protected final ListOrderedMap&lt;Long, Message&gt; history = new ListOrderedMap&lt;&gt;();</span>

  /**
   * Creates a new MessageHistory object.
   *
   * @param channel The {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} to
   *     retrieval history from.
   */
<span class="nc" id="L51">  public MessageHistory(MessageChannel channel) {</span>
<span class="nc" id="L52">    this.channel = channel;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">    if (channel instanceof TextChannel) {</span>
<span class="nc" id="L54">      TextChannel tc = (TextChannel) channel;</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">      if (!tc.getGuild().getSelfMember().hasPermission(tc, Permission.MESSAGE_HISTORY))</span>
<span class="nc" id="L56">        throw new InsufficientPermissionException(Permission.MESSAGE_HISTORY);</span>
    }
<span class="nc" id="L58">  }</span>

  /**
   * The corresponding JDA instance for this MessageHistory
   *
   * @return The corresponding JDA instance
   */
  public JDA getJDA() {
<span class="nc" id="L66">    return channel.getJDA();</span>
  }

  /**
   * The amount of retrieved {@link net.dv8tion.jda.core.entities.Message Messages} by this
   * MessageHistory. &lt;br&gt;
   * This returns {@code 0} until any call to retrieve messages has completed. See {@link
   * #retrievePast(int)} and {@link #retrieveFuture(int)}!
   *
   * @return Amount of retrieved messages
   */
  public int size() {
<span class="nc" id="L78">    return history.size();</span>
  }

  /**
   * Whether this MessageHistory instance has retrieved any messages.
   *
   * @return True, If this MessageHistory instance has not retrieved any messages from discord.
   */
  public boolean isEmpty() {
<span class="nc bnc" id="L87" title="All 2 branches missed.">    return size() == 0;</span>
  }

  /**
   * Returns the {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel} that this
   * MessageHistory is related to.
   *
   * @return The MessageChannel of this history.
   */
  public MessageChannel getChannel() {
<span class="nc" id="L97">    return channel;</span>
  }

  /**
   * Retrieves messages from Discord that were sent before the oldest sent message in
   * MessageHistory's history cache ({@link #getRetrievedHistory()}). &lt;br&gt;
   * Can only retrieve a &lt;b&gt;maximum&lt;/b&gt; of {@code 100} messages at a time. &lt;br&gt;
   * This method has 2 modes of operation: initial retrieval and additional retrieval.
   *
   * &lt;ul&gt;
   *   &lt;li&gt;&lt;b&gt;Initial Retrieval&lt;/b&gt; &lt;br&gt;
   *       This mode is what is used when no {@link net.dv8tion.jda.core.entities.Message Messages}
   *       have been retrieved yet ({@link #getRetrievedHistory()}'s size is 0). Initial retrieval
   *       starts from the most recent message sent to the channel and retrieves backwards from
   *       there. So, if 50 messages are retrieved during this mode, the most recent 50 messages
   *       will be retrieved.
   *   &lt;li&gt;&lt;b&gt;Additional Retrieval&lt;/b&gt; &lt;br&gt;
   *       This mode is used once some {@link net.dv8tion.jda.core.entities.Message Messages} have
   *       already been retrieved from Discord and are stored in MessageHistory's history ({@link
   *       #getRetrievedHistory()}). When retrieving messages in this mode, MessageHistory will
   *       retrieve previous messages starting from the oldest message stored in MessageHistory.
   *       &lt;br&gt;
   *       E.g: If you initially retrieved 10 messages, the next call to this method to retrieve 10
   *       messages would retrieve the &lt;i&gt;next&lt;/i&gt; 10 messages, starting from the oldest message of
   *       the 10 previously retrieved messages.
   * &lt;/ul&gt;
   *
   * &lt;p&gt;Possible {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} include:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE} &lt;br&gt;
   *       Can occur if retrieving in Additional Mode and the Message being used as the marker for
   *       the last retrieved Message was deleted. Currently, to fix this, you need to create a new
   *       {@link net.dv8tion.jda.core.entities.MessageHistory MessageHistory} instance.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS} &lt;br&gt;
   *       Can occur if the request for history retrieval was executed &lt;i&gt;after&lt;/i&gt; JDA lost access
   *       to the Channel, typically due to the account being removed from the {@link
   *       net.dv8tion.jda.core.entities.Guild Guild} or {@link
   *       net.dv8tion.jda.client.entities.Group Group}.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS
   *       MISSING_PERMISSIONS} &lt;br&gt;
   *       Can occur if the request for history retrieval was executed &lt;i&gt;after&lt;/i&gt; JDA lost the
   *       {@link net.dv8tion.jda.core.Permission#MESSAGE_HISTORY} permission.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL} &lt;br&gt;
   *       The send request was attempted after the channel was deleted.
   * &lt;/ul&gt;
   *
   * @param amount The amount of {@link net.dv8tion.jda.core.entities.Message Messages} to retrieve.
   * @throws java.lang.IllegalArgumentException The the {@code amount} is less than {@code 1} or
   *     greater than {@code 100}.
   * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: {@link
   *     java.util.List List}{@literal &lt;}{@link net.dv8tion.jda.core.entities.Message
   *     Message}{@literal &gt;} &lt;br&gt;
   *     Retrieved Messages are placed in a List and provided in order of most recent to oldest with
   *     most recent starting at index 0. If the list is empty, there were no more messages left to
   *     retrieve.
   */
  public RestAction&lt;List&lt;Message&gt;&gt; retrievePast(int amount) {
<span class="nc bnc" id="L155" title="All 4 branches missed.">    if (amount &gt; 100 || amount &lt; 1)</span>
<span class="nc" id="L156">      throw new IllegalArgumentException(</span>
          &quot;Message retrieval limit is between 1 and 100 messages. No more, no less. Limit provided: &quot;
              + amount);

<span class="nc" id="L160">    Route.CompiledRoute route =</span>
        Route.Messages.GET_MESSAGE_HISTORY
<span class="nc" id="L162">            .compile(channel.getId())</span>
<span class="nc" id="L163">            .withQueryParams(&quot;limit&quot;, Integer.toString(amount));</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">    if (!history.isEmpty())</span>
<span class="nc" id="L166">      route = route.withQueryParams(&quot;before&quot;, String.valueOf(history.lastKey()));</span>

<span class="nc" id="L168">    return new RestAction&lt;List&lt;Message&gt;&gt;(getJDA(), route) {</span>
      @Override
      protected void handleResponse(Response response, Request&lt;List&lt;Message&gt;&gt; request) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (!response.isOk()) {</span>
<span class="nc" id="L172">          request.onFailure(response);</span>
<span class="nc" id="L173">          return;</span>
        }

<span class="nc" id="L176">        EntityBuilder builder = api.getEntityBuilder();</span>
        ;
<span class="nc" id="L178">        LinkedList&lt;Message&gt; msgs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L179">        JSONArray historyJson = response.getArray();</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int i = 0; i &lt; historyJson.length(); i++)</span>
<span class="nc" id="L182">          msgs.add(builder.createMessage(historyJson.getJSONObject(i)));</span>

<span class="nc" id="L184">        msgs.forEach(msg -&gt; history.put(msg.getIdLong(), msg));</span>
<span class="nc" id="L185">        request.onSuccess(msgs);</span>
<span class="nc" id="L186">      }</span>
    };
  }

  /**
   * Retrieves messages from Discord that were sent more recently than the most recently sent
   * message in MessageHistory's history cache ({@link #getRetrievedHistory()}). Use case for this
   * method is for getting more recent messages after jumping to a specific point in history using
   * something like {@link MessageChannel#getHistoryAround(String, int)}. &lt;br&gt;
   * This method works in the same way as {@link #retrievePast(int)}'s Additional Retrieval mode.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method can only be used after {@link net.dv8tion.jda.core.entities.Message
   * Messages} have already been retrieved from Discord.
   *
   * &lt;p&gt;Possible {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} include:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE} &lt;br&gt;
   *       Can occur if retrieving in Additional Mode and the Message being used as the marker for
   *       the last retrieved Message was deleted. Currently, to fix this, you need to create a new
   *       {@link net.dv8tion.jda.core.entities.MessageHistory MessageHistory} instance.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS} &lt;br&gt;
   *       Can occur if the request for history retrieval was executed &lt;i&gt;after&lt;/i&gt; JDA lost access
   *       to the Channel, typically due to the account being removed from the {@link
   *       net.dv8tion.jda.core.entities.Guild Guild} or {@link
   *       net.dv8tion.jda.client.entities.Group Group}.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS
   *       MISSING_PERMISSIONS} &lt;br&gt;
   *       Can occur if the request for history retrieval was executed &lt;i&gt;after&lt;/i&gt; JDA lost the
   *       {@link net.dv8tion.jda.core.Permission#MESSAGE_HISTORY} permission.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL} &lt;br&gt;
   *       The send request was attempted after the channel was deleted.
   * &lt;/ul&gt;
   *
   * @param amount The amount of {@link net.dv8tion.jda.core.entities.Message Messages} to retrieve.
   * @throws java.lang.IllegalArgumentException The the {@code amount} is less than {@code 1} or
   *     greater than {@code 100}.
   * @throws java.lang.IllegalStateException If no messages have been retrieved by this
   *     MessageHistory.
   * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: {@link
   *     java.util.List List}{@literal &lt;}{@link net.dv8tion.jda.core.entities.Message
   *     Message}{@literal &gt;} &lt;br&gt;
   *     Retrieved Messages are placed in a List and provided in order of most recent to oldest with
   *     most recent starting at index 0. If the list is empty, there were no more messages left to
   *     retrieve.
   */
  public RestAction&lt;List&lt;Message&gt;&gt; retrieveFuture(int amount) {
<span class="nc bnc" id="L233" title="All 4 branches missed.">    if (amount &gt; 100 || amount &lt; 1)</span>
<span class="nc" id="L234">      throw new IllegalArgumentException(</span>
          &quot;Message retrieval limit is between 1 and 100 messages. No more, no less. Limit provided: &quot;
              + amount);

<span class="nc bnc" id="L238" title="All 2 branches missed.">    if (history.isEmpty())</span>
<span class="nc" id="L239">      throw new IllegalStateException(</span>
          &quot;No messages have been retrieved yet, so there is no message to act as a marker to retrieve more recent messages based on.&quot;);

<span class="nc" id="L242">    Route.CompiledRoute route =</span>
        Route.Messages.GET_MESSAGE_HISTORY
<span class="nc" id="L244">            .compile(channel.getId())</span>
<span class="nc" id="L245">            .withQueryParams(</span>
<span class="nc" id="L246">                &quot;limit&quot;, Integer.toString(amount), &quot;after&quot;, String.valueOf(history.firstKey()));</span>
<span class="nc" id="L247">    return new RestAction&lt;List&lt;Message&gt;&gt;(getJDA(), route) {</span>
      @Override
      protected void handleResponse(Response response, Request&lt;List&lt;Message&gt;&gt; request) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (!response.isOk()) {</span>
<span class="nc" id="L251">          request.onFailure(response);</span>
<span class="nc" id="L252">          return;</span>
        }

<span class="nc" id="L255">        EntityBuilder builder = api.getEntityBuilder();</span>
        ;
<span class="nc" id="L257">        LinkedList&lt;Message&gt; msgs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L258">        JSONArray historyJson = response.getArray();</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">        for (int i = 0; i &lt; historyJson.length(); i++)</span>
<span class="nc" id="L261">          msgs.add(builder.createMessage(historyJson.getJSONObject(i)));</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (Iterator&lt;Message&gt; it = msgs.descendingIterator(); it.hasNext(); ) {</span>
<span class="nc" id="L264">          Message m = it.next();</span>
<span class="nc" id="L265">          history.put(0, m.getIdLong(), m);</span>
<span class="nc" id="L266">        }</span>

<span class="nc" id="L268">        request.onSuccess(msgs);</span>
<span class="nc" id="L269">      }</span>
    };
  }

  /**
   * Returns a List of Messages, sorted starting from newest to oldest, of all message that have
   * already been retrieved from Discord with this MessageHistory object using the {@link
   * #retrievePast(int)}, {@link #retrieveFuture(int)}, and {@link
   * net.dv8tion.jda.core.entities.MessageChannel#getHistoryAround(String, int)} methods.
   *
   * @return A List of Messages, sorted newest to oldest.
   */
  public List&lt;Message&gt; getRetrievedHistory() {
<span class="nc" id="L282">    int size = size();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">    if (size == 0) return Collections.emptyList();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">    else if (size == 1) return Collections.singletonList(history.getValue(0));</span>
<span class="nc" id="L285">    return Collections.unmodifiableList(new ArrayList&lt;&gt;(history.values()));</span>
  }

  /**
   * Used to get a Message from the set of already retrieved message via it's message Id. &lt;br&gt;
   * If a Message with the provided id has not already been retrieved (thus, doesn't not exist in
   * this MessageHistory object), then this method returns null.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This methods is not the same as {@link MessageChannel#getMessageById(String)},
   * which itself queries Discord. This method is for getting a message that has already been
   * retrieved by this MessageHistory object.
   *
   * @param id The id of the requested Message.
   * @throws java.lang.IllegalArgumentException If the provided {@code id} is null or empty.
   * @throws java.lang.NumberFormatException If the provided {@code id} cannot be parsed by {@link
   *     Long#parseLong(String)}
   * @return Possibly-null Message with the same {@code id} as the one provided.
   */
  public Message getMessageById(String id) {
<span class="nc" id="L304">    return getMessageById(MiscUtil.parseSnowflake(id));</span>
  }

  /**
   * Used to get a Message from the set of already retrieved message via it's message Id. &lt;br&gt;
   * If a Message with the provided id has not already been retrieved (thus, doesn't not exist in
   * this MessageHistory object), then this method returns null.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This methods is not the same as {@link MessageChannel#getMessageById(long)},
   * which itself queries Discord. This method is for getting a message that has already been
   * retrieved by this MessageHistory object.
   *
   * @param id The id of the requested Message.
   * @return Possibly-null Message with the same {@code id} as the one provided.
   */
  public Message getMessageById(long id) {
<span class="nc" id="L320">    return history.get(id);</span>
  }

  /**
   * Constructs a {@link net.dv8tion.jda.core.entities.MessageHistory MessageHistory} with the
   * initially retrieved history of messages sent after the mentioned message ID (exclusive). &lt;br&gt;
   * The provided ID need not be valid!
   *
   * &lt;p&gt;Alternatively you can use {@link
   * net.dv8tion.jda.core.entities.MessageChannel#getHistoryAfter(String, int)
   * MessageChannel.getHistoryAfter(...)}
   *
   * &lt;p&gt;&lt;b&gt;Example&lt;/b&gt; &lt;br&gt;
   * {@code MessageHistory history = MessageHistory.getHistoryAfter(channel,
   * messageId).limit(60).complete()} &lt;br&gt;
   * Will return a MessageHistory instance with the first 60 messages sent after the provided
   * message ID.
   *
   * &lt;p&gt;Alternatively you can provide an epoch millisecond timestamp using {@link
   * net.dv8tion.jda.core.utils.MiscUtil#getDiscordTimestamp(long)
   * MiscUtil.getDiscordTimestamp(long)}: &lt;br&gt;
   *
   * &lt;pre&gt;&lt;code&gt;
   * long timestamp = System.currentTimeMillis(); // or any other epoch millis timestamp
   * String discordTimestamp = Long.toUnsignedString(MiscUtil.getDiscordTimestamp(timestamp));
   * MessageHistory history = MessageHistory.getHistoryAfter(channel, discordTimestamp).complete();
   * &lt;/code&gt;&lt;/pre&gt;
   *
   * @param channel The {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel}
   * @param messageId The pivot ID to use
   * @throws java.lang.IllegalArgumentException If any of the provided arguments is {@code null}; Or
   *     if the provided messageId contains whitespace
   * @throws net.dv8tion.jda.core.exceptions.InsufficientPermissionException If this is a
   *     TextChannel and the currently logged in account does not have the permission {@link
   *     net.dv8tion.jda.core.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}
   * @return {@link net.dv8tion.jda.core.entities.MessageHistory.MessageRetrieveAction
   *     MessageRetrieveAction}
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAfter(String, int)
   *     MessageChannel.getHistoryAfter(String, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAfter(long, int)
   *     MessageChannel.getHistoryAfter(long, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAfter(Message, int)
   *     MessageChannel.getHistoryAfter(Message, int)
   */
  public static MessageRetrieveAction getHistoryAfter(MessageChannel channel, String messageId) {
<span class="nc" id="L365">    checkArguments(channel, messageId);</span>
<span class="nc" id="L366">    Route.CompiledRoute route =</span>
        Route.Messages.GET_MESSAGE_HISTORY
<span class="nc" id="L368">            .compile(channel.getId())</span>
<span class="nc" id="L369">            .withQueryParams(&quot;after&quot;, messageId);</span>
<span class="nc" id="L370">    return new MessageRetrieveAction(route, channel);</span>
  }

  /**
   * Constructs a {@link net.dv8tion.jda.core.entities.MessageHistory MessageHistory} with the
   * initially retrieved history of messages sent before the mentioned message ID (exclusive). &lt;br&gt;
   * The provided ID need not be valid!
   *
   * &lt;p&gt;Alternatively you can use {@link
   * net.dv8tion.jda.core.entities.MessageChannel#getHistoryBefore(String, int)
   * MessageChannel.getHistoryBefore(...)}
   *
   * &lt;p&gt;&lt;b&gt;Example&lt;/b&gt; &lt;br&gt;
   * {@code MessageHistory history = MessageHistory.getHistoryBefore(channel,
   * messageId).limit(60).complete()} &lt;br&gt;
   * Will return a MessageHistory instance with the first 60 messages sent before the provided
   * message ID.
   *
   * &lt;p&gt;Alternatively you can provide an epoch millisecond timestamp using {@link
   * net.dv8tion.jda.core.utils.MiscUtil#getDiscordTimestamp(long)
   * MiscUtil.getDiscordTimestamp(long)}: &lt;br&gt;
   *
   * &lt;pre&gt;&lt;code&gt;
   * long timestamp = System.currentTimeMillis(); // or any other epoch millis timestamp
   * String discordTimestamp = Long.toUnsignedString(MiscUtil.getDiscordTimestamp(timestamp));
   * MessageHistory history = MessageHistory.getHistoryBefore(channel, discordTimestamp).complete();
   * &lt;/code&gt;&lt;/pre&gt;
   *
   * @param channel The {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel}
   * @param messageId The pivot ID to use
   * @throws java.lang.IllegalArgumentException If any of the provided arguments is {@code null}; Or
   *     if the provided messageId contains whitespace
   * @throws net.dv8tion.jda.core.exceptions.InsufficientPermissionException If this is a
   *     TextChannel and the currently logged in account does not have the permission {@link
   *     net.dv8tion.jda.core.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}
   * @return {@link net.dv8tion.jda.core.entities.MessageHistory.MessageRetrieveAction
   *     MessageRetrieveAction}
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryBefore(String, int)
   *     MessageChannel.getHistoryBefore(String, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryBefore(long, int)
   *     MessageChannel.getHistoryBefore(long, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryBefore(Message, int)
   *     MessageChannel.getHistoryBefore(Message, int)
   */
  public static MessageRetrieveAction getHistoryBefore(MessageChannel channel, String messageId) {
<span class="nc" id="L415">    checkArguments(channel, messageId);</span>
<span class="nc" id="L416">    Route.CompiledRoute route =</span>
        Route.Messages.GET_MESSAGE_HISTORY
<span class="nc" id="L418">            .compile(channel.getId())</span>
<span class="nc" id="L419">            .withQueryParams(&quot;before&quot;, messageId);</span>
<span class="nc" id="L420">    return new MessageRetrieveAction(route, channel);</span>
  }

  /**
   * Constructs a {@link net.dv8tion.jda.core.entities.MessageHistory MessageHistory} with the
   * initially retrieved history of messages sent around the mentioned message ID (inclusive). &lt;br&gt;
   * The provided ID need not be valid!
   *
   * &lt;p&gt;Alternatively you can use {@link
   * net.dv8tion.jda.core.entities.MessageChannel#getHistoryAround(String, int)
   * MessageChannel.getHistoryAround(...)}
   *
   * &lt;p&gt;&lt;b&gt;Example&lt;/b&gt; &lt;br&gt;
   * {@code MessageHistory history = MessageHistory.getHistoryAround(channel,
   * messageId).limit(60).complete()} &lt;br&gt;
   * Will return a MessageHistory instance with the first 60 messages sent around the provided
   * message ID.
   *
   * &lt;p&gt;Alternatively you can provide an epoch millisecond timestamp using {@link
   * net.dv8tion.jda.core.utils.MiscUtil#getDiscordTimestamp(long)
   * MiscUtil.getDiscordTimestamp(long)}: &lt;br&gt;
   *
   * &lt;pre&gt;&lt;code&gt;
   * long timestamp = System.currentTimeMillis(); // or any other epoch millis timestamp
   * String discordTimestamp = Long.toUnsignedString(MiscUtil.getDiscordTimestamp(timestamp));
   * MessageHistory history = MessageHistory.getHistoryAround(channel, discordTimestamp).complete();
   * &lt;/code&gt;&lt;/pre&gt;
   *
   * @param channel The {@link net.dv8tion.jda.core.entities.MessageChannel MessageChannel}
   * @param messageId The pivot ID to use
   * @throws java.lang.IllegalArgumentException If any of the provided arguments is {@code null}; Or
   *     if the provided messageId contains whitespace
   * @throws net.dv8tion.jda.core.exceptions.InsufficientPermissionException If this is a
   *     TextChannel and the currently logged in account does not have the permission {@link
   *     net.dv8tion.jda.core.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}
   * @return {@link net.dv8tion.jda.core.entities.MessageHistory.MessageRetrieveAction
   *     MessageRetrieveAction}
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAround(String, int)
   *     MessageChannel.getHistoryAround(String, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAround(long, int)
   *     MessageChannel.getHistoryAround(long, int)
   * @see net.dv8tion.jda.core.entities.MessageChannel#getHistoryAround(Message, int)
   *     MessageChannel.getHistoryAround(Message, int)
   */
  public static MessageRetrieveAction getHistoryAround(MessageChannel channel, String messageId) {
<span class="nc" id="L465">    checkArguments(channel, messageId);</span>
<span class="nc" id="L466">    Route.CompiledRoute route =</span>
        Route.Messages.GET_MESSAGE_HISTORY
<span class="nc" id="L468">            .compile(channel.getId())</span>
<span class="nc" id="L469">            .withQueryParams(&quot;around&quot;, messageId);</span>
<span class="nc" id="L470">    return new MessageRetrieveAction(route, channel);</span>
  }

  private static void checkArguments(MessageChannel channel, String messageId) {
<span class="nc" id="L474">    Checks.noWhitespace(messageId, &quot;Message ID&quot;);</span>
<span class="nc" id="L475">    Checks.notNull(channel, &quot;Channel&quot;);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">    if (channel.getType() == ChannelType.TEXT) {</span>
<span class="nc" id="L477">      TextChannel t = (TextChannel) channel;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (!t.getGuild().getSelfMember().hasPermission(t, Permission.MESSAGE_HISTORY))</span>
<span class="nc" id="L479">        throw new InsufficientPermissionException(Permission.MESSAGE_HISTORY);</span>
    }
<span class="nc" id="L481">  }</span>

  /**
   * Constructs a MessageHistory object with initially retrieved Messages before or after a certain
   * pivot message id. &lt;br&gt;
   * Allows to {@link #limit(Integer) limit} the amount to retrieve for better performance!
   */
  public static class MessageRetrieveAction extends RestAction&lt;MessageHistory&gt; {
    private final MessageChannel channel;
    private Integer limit;

    protected MessageRetrieveAction(Route.CompiledRoute route, MessageChannel channel) {
<span class="nc" id="L493">      super(channel.getJDA(), route);</span>
<span class="nc" id="L494">      this.channel = channel;</span>
<span class="nc" id="L495">    }</span>

    /**
     * Limit between 1-100 messages that should be retrieved.
     *
     * @param limit The limit to use, or {@code null} to use default 50
     * @throws java.lang.IllegalArgumentException If the provided limit is not between 1-100
     * @return The current MessageRetrieveAction for chaining convenience
     */
    public MessageRetrieveAction limit(Integer limit) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">      if (limit != null) {</span>
<span class="nc" id="L506">        Checks.positive(limit, &quot;Limit&quot;);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        Checks.check(limit &lt;= 100, &quot;Limit may not exceed 100!&quot;);</span>
      }
<span class="nc" id="L509">      this.limit = limit;</span>
<span class="nc" id="L510">      return this;</span>
    }

    @Override
    protected Route.CompiledRoute finalizeRoute() {
<span class="nc" id="L515">      final Route.CompiledRoute route = super.finalizeRoute();</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">      return limit == null ? route : route.withQueryParams(&quot;limit&quot;, String.valueOf(limit));</span>
    }

    @Override
    protected void handleResponse(Response response, Request&lt;MessageHistory&gt; request) {
<span class="nc bnc" id="L521" title="All 2 branches missed.">      if (!response.isOk()) {</span>
<span class="nc" id="L522">        request.onFailure(response);</span>
<span class="nc" id="L523">        return;</span>
      }
<span class="nc" id="L525">      final MessageHistory result = new MessageHistory(channel);</span>
<span class="nc" id="L526">      final JSONArray array = response.getArray();</span>
<span class="nc" id="L527">      final EntityBuilder builder = api.getEntityBuilder();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">      for (int i = 0; i &lt; array.length(); i++) {</span>
        try {
<span class="nc" id="L530">          JSONObject obj = array.getJSONObject(i);</span>
<span class="nc" id="L531">          result.history.put(obj.getLong(&quot;id&quot;), builder.createMessage(obj, channel, false));</span>
<span class="nc" id="L532">        } catch (JSONException | NullPointerException e) {</span>
<span class="nc" id="L533">          LOG.warn(&quot;Encountered exception in MessagePagination&quot;, e);</span>
<span class="nc" id="L534">        }</span>
      }
<span class="nc" id="L536">      request.onSuccess(result);</span>
<span class="nc" id="L537">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>